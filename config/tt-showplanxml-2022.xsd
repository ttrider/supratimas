<?xml version="1.0" encoding="utf-8"?>
<xsd:schema targetNamespace="http://schemas.microsoft.com/sqlserver/2004/07/showplan" 
  xmlns:ssp="http://schemas.ttrider.com/supratimas/annotations" 
  xmlns:shp="http://schemas.microsoft.com/sqlserver/2004/07/showplan" 
  xmlns:xsd="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified" version="1.2" blockDefault="#all">
  <xsd:annotation>
    <xsd:documentation>
        The following schema for Microsoft SQL Server describes output from the 
        showplan functionality in XML format.  

	Microsoft does not make any representation or warranty regarding the 
	schema or any product or item developed based on the schema. The schema 
	is provided to you on an AS IS basis.  Microsoft disclaims all express, 
	implied and statutory warranties, including but not limited to the implied 
	warranties of merchantability, fitness for a particular purpose, and freedom 
	from infringement. Without limiting the generality of the foregoing, 
	Microsoft does not make any warranty of any kind that any item developed 
	based on the schema, or any portion of the schema, will not infringe any 
	copyright, patent, trade secret, or other intellectual property right of any 
	person or entity in any country. It is your responsibility to seek licenses 
	for such intellectual property rights where appropriate.

	MICROSOFT SHALL NOT BE LIABLE FOR ANY DAMAGES OF ANY KIND ARISING OUT OF OR 
	IN CONNECTION WITH THE USE OF THE SCHEMA, INCLUDING WITHOUT LIMITATION, ANY 
	DIRECT, INDIRECT, INCIDENTAL, CONSEQUENTIAL (INCLUDING ANY LOST PROFITS), 
	PUNITIVE OR SPECIAL DAMAGES, WHETHER OR NOT MICROSOFT HAS BEEN ADVISED OF 
	SUCH DAMAGES. 


	(c) Microsoft Corporation. All rights reserved.
  
        </xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
		<xsd:documentation>Last updated: 10/10/2022</xsd:documentation>
  </xsd:annotation>
  <xsd:element name="ShowPlanXML">
    <xsd:complexType>
      <xsd:annotation>
				<xsd:documentation>This is the root element</xsd:documentation>
      </xsd:annotation>
      <xsd:sequence>
        <xsd:element name="BatchSequence">
          <xsd:complexType>
            <xsd:sequence>
              <xsd:element name="Batch" minOccurs="1" maxOccurs="unbounded">
                <xsd:complexType>
                  <ssp:annotation planBatch="true" />
                  <xsd:sequence>
										<xsd:element name="Statements" type="shp:StmtBlockType" minOccurs="1" maxOccurs="unbounded" />
                  </xsd:sequence>
                </xsd:complexType>
              </xsd:element>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>
      </xsd:sequence>
      <xsd:attribute name="Version" type="xsd:string" use="required">
        <ssp:annotation />
      </xsd:attribute>
      <xsd:attribute name="Build" type="xsd:string" use="required">
        <ssp:annotation />
      </xsd:attribute>
      <xsd:attribute name="ClusteredMode" type="xsd:boolean" use="optional">
        <ssp:annotation />
      </xsd:attribute>
    </xsd:complexType>
  </xsd:element>
	<xsd:complexType name="ExternalDistributedComputationType">
		<xsd:annotation>
			<xsd:documentation>This is only found in the serialized xml for Gen3 external distributed statements.</xsd:documentation>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element name="StmtSimple" type="shp:StmtSimpleType" />
			</xsd:choice>
		</xsd:sequence>
		<xsd:attribute name="EdcShowplanXml" type="xsd:string" use="required" />
	</xsd:complexType>
  <xsd:complexType name="StmtBlockType">
    <xsd:annotation>
			<xsd:documentation>The statement block that contains many statements</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
				<xsd:element name="ExternalDistributedComputation" type="shp:ExternalDistributedComputationType" />
				<xsd:element name="StmtSimple" type="shp:StmtSimpleType" />
				<xsd:element name="StmtCond" type="shp:StmtCondType" />
				<xsd:element name="StmtCursor" type="shp:StmtCursorType" />
				<xsd:element name="StmtReceive" type="shp:StmtReceiveType" />
				<xsd:element name="StmtUseDb" type="shp:StmtUseDbType" />
      </xsd:choice>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="BaseStmtInfoType">
    <ssp:annotation planNode="true" planStatement="true"/>
    <xsd:annotation>
			<xsd:documentation>the type that contains the basic statement information</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="StatementSetOptions" type="shp:SetOptionsType" minOccurs="0" maxOccurs="1">
        <ssp:annotation />
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="StatementCompId" type="xsd:int" use="optional">
      <ssp:annotation property="true" category="General"/>
    </xsd:attribute>
    <xsd:attribute name="StatementEstRows" type="xsd:double" use="optional">
      <ssp:annotation estimated="true" category="General"/>
    </xsd:attribute>
    <xsd:attribute name="StatementId" type="xsd:int" use="optional">
      <ssp:annotation property="true" category="General"/>
    </xsd:attribute>
    <xsd:attribute name="QueryCompilationReplay" type="xsd:int" use="optional">
      <ssp:annotation property="true" category="General"/>
    </xsd:attribute>
    <xsd:attribute name="StatementOptmLevel" type="xsd:string" use="optional">
      <ssp:annotation property="Optimization Level" category="General"/>
    </xsd:attribute>
    <xsd:attribute name="StatementOptmEarlyAbortReason" use="optional">
      <xsd:simpleType>
        <xsd:restriction base="xsd:string">
					<xsd:enumeration value="TimeOut" />
					<xsd:enumeration value="MemoryLimitExceeded" />
					<xsd:enumeration value="GoodEnoughPlanFound" />
        </xsd:restriction>
      </xsd:simpleType>
      <ssp:annotation property="Early Abort Reason" category="General"/>
    </xsd:attribute>
    <xsd:attribute name="CardinalityEstimationModelVersion" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="General"/>
    </xsd:attribute>
    <xsd:attribute name="StatementSubTreeCost" type="xsd:double" use="optional">
      <ssp:annotation setToStatement="true" property="true" category="General"/>
    </xsd:attribute>
    <xsd:attribute name="StatementText" type="xsd:string" use="optional">
      <ssp:annotation setToStatement="true" statementSetter="statementInfo.data = {{value}}"/>
    </xsd:attribute>
    <xsd:attribute name="StatementType" type="xsd:string" use="optional">
      <ssp:annotation title="true" subTitle="true" property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="TemplatePlanGuideDB" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="Plan Guide" />
    </xsd:attribute>
    <xsd:attribute name="TemplatePlanGuideName" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="Plan Guide" />
    </xsd:attribute>
    <xsd:attribute name="PlanGuideDB" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="Plan Guide" />
    </xsd:attribute>
    <xsd:attribute name="PlanGuideName" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="Plan Guide" />
    </xsd:attribute>
    <xsd:attribute name="ParameterizedText" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="Parameterization" />
    </xsd:attribute>
    <xsd:attribute name="ParameterizedPlanHandle" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="Parameterization" />
    </xsd:attribute>
    <xsd:attribute name="QueryHash" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="QueryPlanHash" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="RetrievedFromCache" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="StatementSqlHandle" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="DatabaseContextSettingsId" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="ParentObjectId" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="BatchSqlHandle" type="xsd:string" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="StatementParameterizationType" type="xsd:int" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="SecurityPolicyApplied" type="xsd:boolean" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="BatchModeOnRowStoreUsed" type="xsd:boolean" use="optional">
       <ssp:annotation property="true" category="General" />
    </xsd:attribute>
		<xsd:attribute name="QueryStoreStatementHintId" type="xsd:unsignedLong" use="optional">
       <ssp:annotation property="true" category="General" />
    </xsd:attribute>
		<xsd:attribute name="QueryStoreStatementHintText" type="xsd:string" use="optional">
       <ssp:annotation property="true" category="General" />
    </xsd:attribute>
		<xsd:attribute name="QueryStoreStatementHintSource" type="xsd:string" use="optional">
       <ssp:annotation property="true" category="General" />
    </xsd:attribute>
		<xsd:attribute name="ContainsLedgerTables" type="xsd:boolean" use="optional">
       <ssp:annotation property="true" category="General" />
    </xsd:attribute>

  </xsd:complexType>
  <xsd:complexType name="StmtSimpleType">
    <xsd:annotation>
			<xsd:documentation>The simple statement that may or may not contain query plan, UDF plan, Stored Procedure plan or dispatcher for parameter sensitive plan. </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="shp:BaseStmtInfoType">
        <xsd:sequence>
					<xsd:element name="Dispatcher" type="shp:DispatcherType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="QueryPlan" type="shp:QueryPlanType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="UDF" type="shp:FunctionType" minOccurs="0" maxOccurs="unbounded" />
					<xsd:element name="StoredProc" type="shp:FunctionType" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StmtUseDbType">
    <xsd:annotation>
			<xsd:documentation>Use database statement </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="shp:BaseStmtInfoType">
        <xsd:sequence>
        </xsd:sequence>
        <xsd:attribute name="Database" type="xsd:string" use="required">
          <ssp:annotation subTitle="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StmtCondType">
    <xsd:annotation>
			<xsd:documentation>Complex statement type that is constructed by a condition, a then clause and an optional else clause. </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="shp:BaseStmtInfoType">
        <xsd:sequence>
          <xsd:element name="Condition">
            <xsd:complexType>
              <xsd:sequence>
								<xsd:element name="QueryPlan" type="shp:QueryPlanType" minOccurs="0" maxOccurs="1" />
								<xsd:element name="UDF" type="shp:FunctionType" minOccurs="0" maxOccurs="unbounded" />
              </xsd:sequence>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="Then">
            <xsd:complexType>
              <xsd:sequence>
								<xsd:element name="Statements" type="shp:StmtBlockType" />
              </xsd:sequence>
              <ssp:annotation planNode="true" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="Else" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
              <xsd:sequence>
								<xsd:element name="Statements" type="shp:StmtBlockType" />
              </xsd:sequence>
              <ssp:annotation planNode="true" />
            </xsd:complexType>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StmtCursorType">
    <xsd:annotation>
			<xsd:documentation>The cursor type that might have one or more cursor operations, used in DECLARE CURSOR, OPEN CURSOR and FETCH CURSOR</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="shp:BaseStmtInfoType">
        <xsd:sequence>
					<xsd:element name="CursorPlan" type="shp:CursorPlanType" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StmtReceiveType">
    <xsd:annotation>
			<xsd:documentation>The cursor type that might have one or more cursor operations, used in DECLARE CURSOR, OPEN CURSOR and FETCH CURSOR</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="shp:BaseStmtInfoType">
        <xsd:sequence>
					<xsd:element name="ReceivePlan" type="shp:ReceivePlanType" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="FunctionType">
    <xsd:annotation>
			<xsd:documentation>Shows the plan for the UDF or stored procedure</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
			<xsd:element name="Statements" type="shp:StmtBlockType" />
    </xsd:sequence>
    <xsd:attribute name="ProcName" type="xsd:string">
      <ssp:annotation subTitle="true" property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="IsNativelyCompiled" type="xsd:boolean" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <ssp:annotation planNode="true" />
  </xsd:complexType>
  <xsd:simpleType name="StorageType">
    <xsd:restriction base="xsd:string">
			<xsd:enumeration value="RowStore" />
			<xsd:enumeration value="ColumnStore" />
			<xsd:enumeration value="MemoryOptimized" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ExecutionModeType">
    <xsd:restriction base="xsd:string">
			<xsd:enumeration value="Row" />
			<xsd:enumeration value="Batch" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CursorType">
    <xsd:restriction base="xsd:string">
			<xsd:enumeration value="Dynamic" />
			<xsd:enumeration value="FastForward" />
			<xsd:enumeration value="Keyset" />
			<xsd:enumeration value="SnapShot" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="MemoryGrantWarningType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="Excessive Grant" />
      <xsd:enumeration value="Used More Than Granted" />
      <xsd:enumeration value="Grant Increase" />
    </xsd:restriction>
  </xsd:simpleType>
	<xsd:simpleType name="MemoryGrantFeedbackInfoType">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="Yes: Adjusting" />
			<xsd:enumeration value="Yes: Stable" />
			<xsd:enumeration value="No: First Execution" />
			<xsd:enumeration value="No: Accurate Grant" />
			<xsd:enumeration value="No: Feedback Disabled" />
			<xsd:enumeration value="Yes: Percentile Adjusting" />
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name="DOPFeedbackInfoType">
		<xsd:restriction base="xsd:string">
			<xsd:enumeration value="Yes: Adjusting" />
			<xsd:enumeration value="Yes: Stable" />
			<xsd:enumeration value="No Feedback" />
		</xsd:restriction>
	</xsd:simpleType>
  <xsd:complexType name="CursorPlanType">
    <xsd:sequence>
      <xsd:element name="Operation" minOccurs="0" maxOccurs="2">
        <xsd:annotation>
					<xsd:documentation>The number of occur time depends on how we define the cursor 
	schema. In shiloh, the OPEN CURSOR and FETCH CURSOR doesn't show any plan and won't raise
	error if the cursor doesn't exist. So we must keep the same behaivor, so the minOccurs is 0. If we allow
	the declare cursor to be executed in showplan mode, then the open cursor and declare cursor will have
	plan in showplan mode, the minOccurs will be 1 </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="Dispatcher" type="shp:DispatcherType" minOccurs="0" maxOccurs="1" />
            <xsd:element name="QueryPlan" type="shp:QueryPlanType" />
            <xsd:element name="UDF" type="shp:FunctionType" minOccurs="0" maxOccurs="unbounded" />
          </xsd:sequence>
          <xsd:attribute name="OperationType" use="required">
            <xsd:simpleType>
              <xsd:restriction base="xsd:string">
								<xsd:enumeration value="FetchQuery" />
								<xsd:enumeration value="PopulateQuery" />
								<xsd:enumeration value="RefreshQuery" />
              </xsd:restriction>
            </xsd:simpleType>
            <ssp:annotation property="true" subTitle="true" category="General" />
          </xsd:attribute>
          <ssp:annotation planNode="true" />
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="CursorName" type="xsd:string">
      <ssp:annotation subTitle="true" category="Cursor" displayName="Name" />
    </xsd:attribute>
    <xsd:attribute name="CursorActualType" type="shp:CursorType">
      <ssp:annotation category="Cursor" displayName="Actual Type" />
    </xsd:attribute>
    <xsd:attribute name="CursorRequestedType" type="shp:CursorType">
      <ssp:annotation category="Cursor" displayName="Requested Type" />
    </xsd:attribute>
    <xsd:attribute name="CursorConcurrency">
      <xsd:simpleType>
        <xsd:restriction base="xsd:string">
					<xsd:enumeration value="Read Only" />
					<xsd:enumeration value="Pessimistic" />
					<xsd:enumeration value="Optimistic" />
        </xsd:restriction>
      </xsd:simpleType>
      <ssp:annotation category="Cursor" displayName="Concurrency" />
    </xsd:attribute>
    <xsd:attribute name="ForwardOnly" type="xsd:boolean">
      <ssp:annotation category="Cursor" displayName="Is Forward only" />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="ReceivePlanType">
    <xsd:sequence>
      <xsd:element name="Operation" minOccurs="2" maxOccurs="2">
        <xsd:complexType>
          <xsd:sequence>
						<xsd:element name="QueryPlan" type="shp:QueryPlanType" />
          </xsd:sequence>
          <xsd:attribute name="OperationType">
            <xsd:simpleType>
              <xsd:restriction base="xsd:string">
								<xsd:enumeration value="ReceivePlanSelect" />
								<xsd:enumeration value="ReceivePlanUpdate" />
              </xsd:restriction>
            </xsd:simpleType>
            <ssp:annotation property="true" subTitle="true" category="General" />
          </xsd:attribute>
          <ssp:annotation planNode="true" />
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <!-- 
   *****************************************
   **  
   **  ColumnReference related definitions
   **
   **
   **
   *****************************************
   -->
  <xsd:complexType name="ColumnReferenceType">
    <xsd:sequence>
      <xsd:element name="ScalarOperator" type="shp:ScalarType" minOccurs="0" maxOccurs="1">
        <ssp:annotation />
      </xsd:element>
      <!-- Used for cached expressions -->
      <xsd:element name="InternalInfo" type="shp:InternalInfoType" minOccurs="0" maxOccurs="1"></xsd:element>
    </xsd:sequence>
    <xsd:attribute name="Server" type="xsd:string" use="optional">
      <ssp:annotation category="Column" />
    </xsd:attribute>
    <xsd:attribute name="Database" type="xsd:string" use="optional">
      <ssp:annotation category="Column" />
    </xsd:attribute>
    <xsd:attribute name="Schema" type="xsd:string" use="optional">
      <ssp:annotation category="Column" />
    </xsd:attribute>
    <xsd:attribute name="Table" type="xsd:string" use="optional">
      <ssp:annotation category="Column" />
    </xsd:attribute>
    <xsd:attribute name="Alias" type="xsd:string" use="optional">
      <ssp:annotation category="Column" />
    </xsd:attribute>
    <xsd:attribute name="Column" type="xsd:string" use="required">
      <ssp:annotation category="Column" />
    </xsd:attribute>
    <xsd:attribute name="ComputedColumn" type="xsd:boolean" use="optional">
      <ssp:annotation category="Column" displayName="Is Computed" />
    </xsd:attribute>
    <xsd:attribute name="ParameterDataType" type="xsd:string" use="optional"></xsd:attribute>
    <xsd:attribute name="ParameterCompiledValue" type="xsd:string" use="optional">
      <ssp:annotation category="Column" displayName="Compiled Value" />
    </xsd:attribute>
    <xsd:attribute name="ParameterRuntimeValue" type="xsd:string" use="optional">
      <ssp:annotation category="Column" displayName="Runtime Value" />
    </xsd:attribute>
    <!-- <ssp:annotation interface="IColumnReferenceType" /> -->
  </xsd:complexType>
  <xsd:complexType name="SingleColumnReferenceType">
    <xsd:sequence>
      <xsd:element name="ColumnReference" type="shp:ColumnReferenceType" />
      <ssp:annotation />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="ColumnReferenceListType">
    <xsd:sequence>
      <xsd:element name="ColumnReference" type="shp:ColumnReferenceType" minOccurs="0" maxOccurs="unbounded" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="ScanRangeType">
    <xsd:sequence>
      <xsd:element name="RangeColumns" type="shp:ColumnReferenceListType">
        <ssp:annotation bindToNodeAs="range" />
      </xsd:element>
      <xsd:element name="RangeExpressions" type="shp:ScalarExpressionListType" />
    </xsd:sequence>
		<xsd:attribute name="ScanType" type="shp:CompareOpType" use="required" />
  </xsd:complexType>
  <xsd:complexType name="SeekPredicateType">
    <xsd:sequence>
			<xsd:element name="Prefix" type="shp:ScanRangeType" minOccurs="0" maxOccurs="1" />
			<xsd:element name="StartRange" type="shp:ScanRangeType" minOccurs="0" maxOccurs="1" />
			<xsd:element name="EndRange" type="shp:ScanRangeType" minOccurs="0" maxOccurs="1" />
			<xsd:element name="IsNotNull" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1" />
      <!-- Prefix a=Expr, Start expressions, Start column, End  expressions, nullability -->
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="SeekPredicateNewType">
    <xsd:sequence>
			<xsd:element name="SeekKeys" type="shp:SeekPredicateType" minOccurs="1" maxOccurs="2" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="SeekPredicatePartType">
    <xsd:choice>
			<xsd:element name="SeekPredicateNew" type="shp:SeekPredicateNewType" minOccurs="1" maxOccurs="unbounded" />
    </xsd:choice>
  </xsd:complexType>
  <xsd:complexType name="SeekPredicatesType">
    <xsd:choice>
			<xsd:element name="SeekPredicate" type="shp:SeekPredicateType" minOccurs="1" maxOccurs="unbounded" />
			<xsd:element name="SeekPredicateNew" type="shp:SeekPredicateNewType" minOccurs="1" maxOccurs="unbounded" />
			<xsd:element name="SeekPredicatePart" type="shp:SeekPredicatePartType" minOccurs="1" maxOccurs="unbounded" />
    </xsd:choice>
  </xsd:complexType>
  <xsd:complexType name="ObjectType">
    <xsd:attribute name="Server" type="xsd:string" use="optional">
      <ssp:annotation category="Target" />
    </xsd:attribute>
    <xsd:attribute name="Database" type="xsd:string" use="optional">
      <ssp:annotation category="Target" />
    </xsd:attribute>
    <xsd:attribute name="Schema" type="xsd:string" use="optional">
      <ssp:annotation category="Target" />
    </xsd:attribute>
    <xsd:attribute name="Table" type="xsd:string" use="optional">
      <ssp:annotation category="Target" />
    </xsd:attribute>
    <xsd:attribute name="Index" type="xsd:string" use="optional">
      <ssp:annotation category="Target" />
    </xsd:attribute>
    <xsd:attribute name="Filtered" type="xsd:boolean" use="optional">
      <ssp:annotation category="Target" displayName="Is Filtered" />
    </xsd:attribute>
		<xsd:attribute name="OnlineInbuildIndex" type="xsd:int" use="optional">
      <ssp:annotation category="Target" />
    </xsd:attribute>
		<xsd:attribute name="OnlineIndexBuildMappingIndex" type="xsd:int" use="optional">
      <ssp:annotation category="Target" />
    </xsd:attribute>
    <xsd:attribute name="Alias" type="xsd:string" use="optional">
      <ssp:annotation category="Target" />
    </xsd:attribute>
    <xsd:attribute name="TableReferenceId" type="xsd:int" use="optional">
      <ssp:annotation category="Target" displayName="Reference ID" />
    </xsd:attribute>
    <xsd:attribute name="IndexKind" type="shp:IndexKindType" use="optional">
      <ssp:annotation category="Target" displayName="Index Kind" />
    </xsd:attribute>
    <xsd:attribute name="CloneAccessScope" type="shp:CloneAccessScopeType" use="optional" />
    <xsd:attribute name="Storage" type="shp:StorageType" use="optional" />
    <xsd:attribute name="GraphWorkTableType" type="xsd:int" use="optional" />
		<xsd:attribute name="GraphWorkTableIdentifier" type="xsd:int" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="OrderByType">
    <xsd:sequence>
      <xsd:element name="OrderByColumn" minOccurs="1" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
						<xsd:element name="ColumnReference" type="shp:ColumnReferenceType" />
          </xsd:sequence>
          <xsd:attribute name="Ascending" type="xsd:boolean" use="required">
            <ssp:annotation category="Common" />
          </xsd:attribute>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="DefinedValuesListType">
    <xsd:sequence>
      <xsd:element name="DefinedValue" minOccurs="0" maxOccurs="unbounded">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:choice>
              <xsd:element name="ValueVector">
                <xsd:complexType>
                  <xsd:sequence>
										<xsd:element name="ColumnReference" type="shp:ColumnReferenceType" minOccurs="2" maxOccurs="unbounded" />
                  </xsd:sequence>
                </xsd:complexType>
              </xsd:element>
							<xsd:element name="ColumnReference" type="shp:ColumnReferenceType" />
            </xsd:choice>
            <xsd:choice minOccurs="0" maxOccurs="1">
              <!--SSP: hiding duplicate<xsd:element name="ColumnReference" type="shp:ColumnReferenceType" minOccurs="1" maxOccurs="unbounded"/>-->
              <xsd:element name="ScalarOperator" type="shp:ScalarType" />
              <!-- unbounded for union case -->
            </xsd:choice>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="SpillToTempDbType">
    <xsd:annotation>
			<xsd:documentation>Spill warning information</xsd:documentation>
    </xsd:annotation>
		<xsd:sequence> 
			<!-- Additional information, like spill I/O stats may go here when available -->
		</xsd:sequence>
    <xsd:attribute name="SpillLevel" type="xsd:unsignedLong" use="optional">
      <ssp:annotation category="Common" displayName="Spill Level" />
    </xsd:attribute>
    <xsd:attribute name="SpilledThreadCount" type ="xsd:unsignedLong" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="SortSpillDetailsType">
    <xsd:annotation>
			<xsd:documentation>Sort spill details</xsd:documentation>
    </xsd:annotation>
		<xsd:sequence> 
			<!-- Additional information may go here when available -->
		</xsd:sequence>
		 <xsd:attribute name="GrantedMemoryKb" type ="xsd:unsignedLong" use="optional" />
		 <xsd:attribute name="UsedMemoryKb" type ="xsd:unsignedLong" use="optional" />
		 <xsd:attribute name="WritesToTempDb" type ="xsd:unsignedLong" use="optional" />
		 <xsd:attribute name="ReadsFromTempDb" type ="xsd:unsignedLong" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="HashSpillDetailsType">
    <xsd:annotation>
			<xsd:documentation>Hash spill details</xsd:documentation>
    </xsd:annotation>
		<xsd:sequence> 
			<!-- Additional information may go here when available -->
		</xsd:sequence>
		 <xsd:attribute name="GrantedMemoryKb" type ="xsd:unsignedLong" use="optional" />
		 <xsd:attribute name="UsedMemoryKb" type ="xsd:unsignedLong" use="optional" />
		 <xsd:attribute name="WritesToTempDb" type ="xsd:unsignedLong" use="optional" />
		 <xsd:attribute name="ReadsFromTempDb" type ="xsd:unsignedLong" use="optional" />
	</xsd:complexType>
	<xsd:complexType name="ExchangeSpillDetailsType">
		<xsd:annotation>
			<xsd:documentation>Exchange spill details</xsd:documentation>
		</xsd:annotation>
		<xsd:sequence> 
			<!-- Additional information may go here when available -->
		</xsd:sequence>
		 <xsd:attribute name="WritesToTempDb" type ="xsd:unsignedLong" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="WaitWarningType">
    <xsd:annotation>
			<xsd:documentation>Query wait information</xsd:documentation>
    </xsd:annotation>
		<xsd:sequence> 
			<!-- Additional information may go here when available -->
		</xsd:sequence>
    <xsd:attribute name="WaitType" use="required">
      <xsd:simpleType>
        <xsd:restriction base="xsd:string">
					<xsd:enumeration value="Memory Grant" />
          <!-- to be extended here -->
        </xsd:restriction>
      </xsd:simpleType>
      <ssp:annotation category="Common" displayName="Wait Type" />
    </xsd:attribute>
    <xsd:attribute name="WaitTime" type="xsd:unsignedLong" use="optional">
      <ssp:annotation category="Common" displayName="Wait Time" />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="WaitStatType">
    <xsd:annotation>
			<xsd:documentation>
				Wait statistics during one query execution.
					WaitType: Name of the wait
					WaitTimeMs: Wait time in milliseconds
					WaitCount: Number of waits
			</xsd:documentation>
    </xsd:annotation>
		<xsd:attribute name="WaitType" type="xsd:string" use="required" />
		<xsd:attribute name="WaitTimeMs" type="xsd:unsignedLong" use="required" />
		<xsd:attribute name="WaitCount" type="xsd:unsignedLong" use="required" />
  </xsd:complexType>
  <xsd:complexType name="WaitStatListType">
    <xsd:annotation>
			<xsd:documentation> A list of query wait statistics. </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="Wait" type="shp:WaitStatType" minOccurs="0" maxOccurs="unbounded">
        <ssp:annotation bindToNodeAs="true" />
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="QueryExecTimeType">
    <xsd:annotation>
			<xsd:documentation>
				Shows time statistics for single query execution.
				CpuTime: CPU time in milliseconds
				ElapsedTime: elapsed time in milliseconds
				UdfCpuTime: Cpu time of UDF in milliseconds
				UdfElapsedTime: Elapsed time of UDF in milliseconds
			</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="CpuTime" type="xsd:unsignedLong" use="required">
      <ssp:annotation property="CPU Time" category="Query Execution" />
    </xsd:attribute>
    <xsd:attribute name="ElapsedTime" type="xsd:unsignedLong" use="required">
      <ssp:annotation property="true" category="Query Execution" />
    </xsd:attribute>
    <xsd:attribute name="UdfCpuTime" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="Query Execution" />
    </xsd:attribute>
		<xsd:attribute name="UdfElapsedTime" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="Query Execution" />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="AffectingConvertWarningType">
    <xsd:annotation>
			<xsd:documentation>Warning information for plan-affecting type conversion</xsd:documentation>
    </xsd:annotation>
		<xsd:sequence>
			<!-- Additional information may go here when available -->
		</xsd:sequence>
    <xsd:attribute name="ConvertIssue" use="required">
      <xsd:simpleType>
        <xsd:restriction base="xsd:string">
					<xsd:enumeration value="Cardinality Estimate" />
					<xsd:enumeration value="Seek Plan" />
          <!-- to be extended here -->
        </xsd:restriction>
      </xsd:simpleType>
      <ssp:annotation category="Common" displayName="Convert Issue" />
    </xsd:attribute>
    <xsd:attribute name="Expression" type ="xsd:string" use="required">
      <ssp:annotation category="Common" />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="WarningsType">
    <xsd:annotation>
			<xsd:documentation>List of all possible iterator or query specific warnings (e.g. hash spilling, no join predicate)</xsd:documentation>
    </xsd:annotation>
    <xsd:choice minOccurs="1" maxOccurs="unbounded">
      <xsd:element name="SpillOccurred" type="shp:SpillOccurredType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="warning" />
      </xsd:element>
      <xsd:element name="ColumnsWithNoStatistics" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="warning_no_statistics" />
      </xsd:element>
      <xsd:element name="ColumnsWithStaleStatistics" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="warning_no_statistics" />
      </xsd:element>
      <xsd:element name="SpillToTempDb" type="shp:SpillToTempDbType" minOccurs="0" maxOccurs="unbounded">
        <ssp:annotation bindToNodeAs="warning" />
      </xsd:element>
      <xsd:element name="Wait" type="shp:WaitWarningType" minOccurs="0" maxOccurs="unbounded">
        <ssp:annotation bindToNodeAs="warning" />
      </xsd:element>
      <xsd:element name="PlanAffectingConvert" type="shp:AffectingConvertWarningType" minOccurs="0" maxOccurs="unbounded">
        <ssp:annotation bindToNodeAs="warning" />
      </xsd:element>
      <xsd:element name="SortSpillDetails" type="shp:SortSpillDetailsType" minOccurs="0" maxOccurs="unbounded">
        <ssp:annotation bindToNodeAs="warning" />
      </xsd:element>
      <xsd:element name="HashSpillDetails" type="shp:HashSpillDetailsType" minOccurs="0" maxOccurs="unbounded">
        <ssp:annotation bindToNodeAs="warning" />
      </xsd:element>
      			<xsd:element name="ExchangeSpillDetails" type="shp:ExchangeSpillDetailsType" minOccurs="0" maxOccurs="unbounded">
        <ssp:annotation bindToNodeAs="warning" />
      </xsd:element>
      <xsd:element name="MemoryGrantWarning" type="shp:MemoryGrantWarningInfo" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="warning" />
      </xsd:element>
    </xsd:choice>
		<xsd:attribute name="NoJoinPredicate" type="xsd:boolean" use="optional" />
		<xsd:attribute name="SpatialGuess" type="xsd:boolean" use="optional" />
		<xsd:attribute name="UnmatchedIndexes" type="xsd:boolean" use="optional" />
		<xsd:attribute name="FullUpdateForOnlineIndexBuild" type="xsd:boolean" use="optional" />
	</xsd:complexType>
	<xsd:complexType name="SpillOccurredType">
	<xsd:annotation>
		<xsd:documentation>Spill Warning for last query plan stats</xsd:documentation>
	</xsd:annotation>
	<xsd:attribute name="Detail" type="xsd:boolean" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="MemoryFractionsType">
    <xsd:annotation>
			<xsd:documentation>For memory consuming relational operators, show fraction of memory grant iterator will use</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence />
    <xsd:attribute name="Input" type="xsd:double" use="required">
      <ssp:annotation property="true" category="Memory Fraction" />
    </xsd:attribute>
    <xsd:attribute name="Output" type="xsd:double" use="required">
      <ssp:annotation property="true" category="Memory Fraction" />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="MemoryGrantType">
    <xsd:annotation>
			<xsd:documentation>
				Provide memory grant estimate as well as actual runtime memory grant information.
				Serial required/desired memory attributes are estimated during query compile time for serial execution.
				The rest of attributes provide estimates and counters for query execution time considering actual degree of parallelism.
				SerialRequiredMemory: Required memory in KB if the query runs in serial mode. The query will not start without this memory.
				SerialDesiredMemory: Memory estimated to fit intermediate results in KB if the query runs in serial mode.
				RequiredMemory: Required memory in KB for the chosen degree of parallelism. If the query runs in serial mode, this is the same as SerialRequiredMemory.
				DesiredMemory: Memory estimated to fit intermediate results in KB for the chosen degree of parallelism.  If the query runs in serial mode, this is the same as SerialDesiredMemory.
				RequestedMemory: Memory in KB which the query requests the memory manager to grant. This can be smaller than sum of RequiredMemory and DesiredMemory if it exceeds the maximum allowed for single query.
				GrantWaitTime: Time in seconds if the query has to wait for successful memory grant.
				MaxUsedMemory: Maximum memory in KB used by the query.
				MaxQueryMemory: Maximum memory in KB allowed for single query.
				LastRequestedMemory: Memory in KB which was requested by the query from the memory manager during the last execution.
				IsMemoryGrantFeedbackAdjusted: Information regarding if the memory grant in this plan is adjusted based on memory grant feedback.
			</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence />
    <xsd:attribute name="SerialRequiredMemory" type="xsd:unsignedLong" use="required">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
    <xsd:attribute name="SerialDesiredMemory" type="xsd:unsignedLong" use="required">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
    <xsd:attribute name="RequiredMemory" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
    <xsd:attribute name="DesiredMemory" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
    <xsd:attribute name="RequestedMemory" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
    <xsd:attribute name="GrantWaitTime" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
    <xsd:attribute name="GrantedMemory" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
    <xsd:attribute name="MaxUsedMemory" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
    <xsd:attribute name="MaxQueryMemory" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
		<xsd:attribute name="LastRequestedMemory" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
		<xsd:attribute name="IsMemoryGrantFeedbackAdjusted" type="shp:MemoryGrantFeedbackInfoType" use="optional">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="MemoryGrantWarningInfo">
    <xsd:annotation>
			<xsd:documentation>
				Provide warning information for memory grant.
				GrantWarningKind: Warning kind
				RequestedMemory: Initial grant request in KB
				GrantedMemory: Granted memory in KB
				MaxUsedMemory: Maximum used memory grant in KB
			</xsd:documentation>
    </xsd:annotation>
		<xsd:attribute name="GrantWarningKind" type="shp:MemoryGrantWarningType" use ="required" />
		<xsd:attribute name="RequestedMemory" type="xsd:unsignedLong" use="required" />
		<xsd:attribute name="GrantedMemory" type="xsd:unsignedLong" use="required" />
		<xsd:attribute name="MaxUsedMemory" type="xsd:unsignedLong" use ="required" />
  </xsd:complexType>
  <xsd:simpleType name="TraceFlagScopeType">
    <xsd:restriction base="xsd:string">
			<xsd:enumeration value="Global"/>
			<xsd:enumeration value="Session" />
    </xsd:restriction>
  </xsd:simpleType>
	<xsd:complexType name ="TraceFlagType">
    <xsd:annotation>
			<xsd:documentation>
				Describe a trace flag used in SQL engine.
			</xsd:documentation>
    </xsd:annotation>
		<xsd:attribute name="Value" type="xsd:unsignedLong" use="required" />
		<xsd:attribute name="Scope" type="shp:TraceFlagScopeType" use="required" />
  </xsd:complexType>
  <xsd:complexType name="TraceFlagListType">
    <xsd:annotation>
			<xsd:documentation>
				Collection of trace flags used in SQL engine.
			</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
			<xsd:element name="TraceFlag" type="shp:TraceFlagType" minOccurs="1" maxOccurs="unbounded" />
    </xsd:sequence>
		<xsd:attribute name="IsCompileTime" type="xsd:boolean" use="required" />
  </xsd:complexType>
  <xsd:complexType name="OptimizerHardwareDependentPropertiesType">
    <xsd:annotation>
      <xsd:documentation>
        Provide hardware-dependent properties that affect cost estimate (and hence, query plan choice), as seen by the Query Optimizer.
        EstimatedAvailableMemoryGrant is an estimate of what amount of memory (KB) will be available for this query at the execution time to request a memory grant from.
        EstimatedPagesCached is an estimate of how many pages of data will remain cached in the buffer pool if the query needs to read it again.
        EstimatedAvailableDegreeOfParallelism is an estimate of number of CPUs that can be used to execute the query should the Query Optimizer pick a parallel plan.
        MaxCompileMemory is the maximum memory in KB allowed for query optimizer to use during compilation.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence />
    <xsd:attribute name="EstimatedAvailableMemoryGrant" type="xsd:unsignedLong" use="required">
      <ssp:annotation estimated="Memory Grant" category="Metrics" />
    </xsd:attribute>
    <xsd:attribute name="EstimatedPagesCached" type="xsd:unsignedLong" use="required">
      <ssp:annotation estimated="Pages Cached" category="Metrics" />
    </xsd:attribute>
    <xsd:attribute name="EstimatedAvailableDegreeOfParallelism" type="xsd:unsignedLong" use="optional">
      <ssp:annotation estimated="Available Degree Of Parallelism" category="Metrics" />
    </xsd:attribute>
    <xsd:attribute name="MaxCompileMemory" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="Memory" />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="StatsInfoType">
    <xsd:attribute name="Database" type="xsd:string" use="optional">
		<xsd:annotation>
			<xsd:documentation>
				Information on single statistics used during query optimization.
					Database : name of the database
					Schema : name of the schema
					Table : name of the table
					Statistics : name of the statistics
					ModificationCount : number of modifications since the last update
					SamplingPercent : statistics sampling percentage
					LastUpdate : date when the statistics was updated
			</xsd:documentation>
		</xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="Database" type="xsd:string" use="optional">
      <ssp:annotation  />
    </xsd:attribute>
    <xsd:attribute name="Schema" type="xsd:string" use="optional">
      <ssp:annotation  />
    </xsd:attribute>
    <xsd:attribute name="Table" type="xsd:string" use="optional">
      <ssp:annotation  />
    </xsd:attribute>
    <xsd:attribute name="Statistics" type="xsd:string" use="required">
      <ssp:annotation  />
    </xsd:attribute>
    <xsd:attribute name="ModificationCount" type="xsd:unsignedLong" use="required">
      <ssp:annotation />
    </xsd:attribute>
    <xsd:attribute name="SamplingPercent" type="xsd:double" use="required">
      <ssp:annotation  />
    </xsd:attribute>
    <xsd:attribute name="LastUpdate" type="xsd:dateTime" use="optional">
      <ssp:annotation  />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="OptimizerStatsUsageType">
		<xsd:annotation>
			<xsd:documentation>
				List of statistics info used during query optimization
			</xsd:documentation>
		</xsd:annotation>
    <xsd:sequence>
			<xsd:element name="StatisticsInfo" type="shp:StatsInfoType" minOccurs="1" maxOccurs="unbounded" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="RunTimeInformationType">
    <xsd:annotation>
			<xsd:documentation>Runtime information provided from statistics_xml for each relational iterator</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="RunTimeCountersPerThread" minOccurs="1" maxOccurs="unbounded">
        <xsd:complexType>
					<xsd:sequence />
					<xsd:attribute name="Thread" type="xsd:int" use="required" />
					<xsd:attribute name="BrickId" type="xsd:int" use="optional" />
					<xsd:attribute name="ActualRebinds" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualRewinds" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualRows" type="xsd:unsignedLong" use="required" />
					<xsd:attribute name="RowRequalifications" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualRowsRead" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="Batches" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualEndOfScans" type="xsd:unsignedLong" use="required" />
					<xsd:attribute name="ActualExecutions" type="xsd:unsignedLong" use="required" />
					<xsd:attribute name="ActualExecutionMode" type="shp:ExecutionModeType" use="optional" />
          <!-- more optional counters -->
					<xsd:attribute name="TaskAddr" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="SchedulerId" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="FirstActiveTime" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="LastActiveTime" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="OpenTime" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="FirstRowTime" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="LastRowTime" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="CloseTime" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualElapsedms" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualCPUms" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualScans" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualLogicalReads" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualPhysicalReads" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualPageServerReads" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualReadAheads" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualPageServerReadAheads" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualLobLogicalReads" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualLobPhysicalReads" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualLobPageServerReads" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualLobReadAheads" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualLobPageServerReadAheads" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="SegmentReads" type="xsd:int" use="optional" />
					<xsd:attribute name="SegmentSkips" type="xsd:int" use="optional" />
					<xsd:attribute name="ActualLocallyAggregatedRows" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="InputMemoryGrant" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="OutputMemoryGrant" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="UsedMemoryGrant" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="IsInterleavedExecuted" type="xsd:boolean" use="optional" />
					<xsd:attribute name="ActualJoinType" type="shp:PhysicalOpType" use="optional" />
					<xsd:attribute name="HpcRowCount" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="HpcKernelElapsedUs" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="HpcHostToDeviceBytes" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="HpcDeviceToHostBytes" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualPageServerPushedPageIDs" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualPageServerRowsReturned" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualPageServerRowsRead" type="xsd:unsignedLong" use="optional" />
					<xsd:attribute name="ActualPageServerPushedReads" type="xsd:unsignedLong" use="optional" />
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="RunTimePartitionSummaryType">
    <xsd:annotation>
			<xsd:documentation>Runtime partition information provided in statistics xml for each relational iterator that support partitioning</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="PartitionsAccessed" minOccurs="1" maxOccurs="1">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="PartitionRange" minOccurs="0" maxOccurs="unbounded">
              <xsd:complexType>
                <xsd:attribute name="Start" type="xsd:unsignedLong" use="required">
                  <ssp:annotation category="Common" />
                </xsd:attribute>
                <xsd:attribute name="End" type="xsd:unsignedLong" use="required">
                  <ssp:annotation category="Common" />
                </xsd:attribute>
              </xsd:complexType>
            </xsd:element>
          </xsd:sequence>
          <xsd:attribute name="PartitionCount" type="xsd:unsignedLong" use="required">
            <ssp:annotation category="Common" displayName="Partition Count" />
          </xsd:attribute>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="IndexedViewInfoType">
    <xsd:annotation>
			<xsd:documentation>Additional information about an indexed view. It includes all tables in the query that were replaced by the indexed view.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="Object" type="shp:ObjectType" minOccurs="0" maxOccurs="unbounded">
        <ssp:annotation bindToNodeAs="indexed_view" />
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="RollupInfoType">
    <xsd:annotation>
			<xsd:documentation>Additional information about a rollup. The highest level is the number of group by columns.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
			<xsd:element name="RollupLevel" type="shp:RollupLevelType" minOccurs="2" maxOccurs="unbounded" />
    </xsd:sequence>
    <xsd:attribute name="HighestLevel" type="xsd:int" use="required">
      <ssp:annotation category="Common" displayName="Highest Level" />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="RollupLevelType">
    <xsd:annotation>
			<xsd:documentation>A level that is output by the rollup.  Level 0 is the base aggregation, equivalent to the statement without 'WITH ROLLUP'.  The highest level is the grand total, or group by all.  Level 0 is always output, and at least one higher level.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="Level" type="xsd:int" use="required">
      <ssp:annotation category="Common" />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="StarJoinInfoType">
    <xsd:annotation>
			<xsd:documentation>Additional information about Star Join structure.</xsd:documentation>
    </xsd:annotation>
		<xsd:attribute name="Root" type="xsd:boolean" use="optional" />
    <xsd:attribute name="OperationType" use="required">
      <xsd:simpleType>
        <xsd:restriction base="xsd:string">
					<xsd:enumeration value="Fetch" />
					<xsd:enumeration value="Index Intersection" />
					<xsd:enumeration value="Index Filter" />
					<xsd:enumeration value="Index Lookup" />
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="InternalInfoType">
    <xsd:annotation>
			<xsd:documentation>Arbitrary content type</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
			<xsd:any namespace="##any" minOccurs="0" maxOccurs="unbounded" processContents="skip" />
    </xsd:sequence>
    <xsd:anyAttribute namespace="##any" processContents="skip" />
  </xsd:complexType>
	<xsd:complexType name="OptimizationReplayType">
		<xsd:attribute name="Script" type="xsd:string" use="required" />
	</xsd:complexType>
  <xsd:complexType name="ThreadStatType">
    <xsd:annotation>
			<xsd:documentation>
			Information on parallel thread usage.
			Branches: Attribute. total number of concurrent branches of query plan.  
				Query would need additional worker threads of at least (Branches)* (Degree of Parallelism)
			UsedThreads: Attribute maximum number of used parallel threads.  This is available only for statistics XML
			Then follows a list of one or more ThreadReservation elements.
			</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
			<xsd:element name="ThreadReservation" type="shp:ThreadReservationType" minOccurs="0" maxOccurs="unbounded" />
    </xsd:sequence>
    <xsd:attribute name="Branches" type="xsd:int" use="required">
      <ssp:annotation category="Thread Data" />
    </xsd:attribute>
    <xsd:attribute name="UsedThreads" type="xsd:int" use="optional">
      <ssp:annotation category="Thread Data" displayName="Used Threads" />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="ThreadReservationType">
    <xsd:annotation>
			<xsd:documentation>
			Information on how parallel threads are reserved on NUMA node
			NodeId: ID of NUMA node where this query is chosen to run
			ReservedThreads: number of reserved parallel thread on this NUMA node
			</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="NodeId" type="xsd:int" use="optional">
      <ssp:annotation category="Thread Data" displayName="Node ID" />
    </xsd:attribute>
    <xsd:attribute name="ReservedThreads" type="xsd:int" use="required">
      <ssp:annotation category="Thread Data" displayName="Reserved Threads" />
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="MissingIndexesType">
    <xsd:sequence>
      <xsd:element name="MissingIndexGroup" type="shp:MissingIndexGroupType" minOccurs="1" maxOccurs="unbounded">
        <ssp:annotation />
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="MissingIndexGroupType">
    <xsd:sequence>
			<xsd:element name="MissingIndex" type="shp:MissingIndexType" minOccurs="1" maxOccurs="unbounded" />
    </xsd:sequence>
		<xsd:attribute name="Impact" type="xsd:double" use="required" />
  </xsd:complexType>
  <xsd:complexType name="MissingIndexType">
    <xsd:sequence>
			<xsd:element name="ColumnGroup" type="shp:ColumnGroupType" minOccurs="1" maxOccurs="3" />
    </xsd:sequence>
		<xsd:attribute name="Database" type="xsd:string" use="required" />
		<xsd:attribute name="Schema" type="xsd:string" use="required" />
		<xsd:attribute name="Table" type="xsd:string" use="required" />
  </xsd:complexType>
  <xsd:complexType name="ColumnGroupType">
    <xsd:sequence>
			<xsd:element name="Column" type="shp:ColumnType" minOccurs="1" maxOccurs="unbounded" />
    </xsd:sequence>
    <xsd:attribute name="Usage" use="required">
      <xsd:simpleType>
        <xsd:restriction base="xsd:string">
					<xsd:enumeration value="EQUALITY" />
					<xsd:enumeration value="INEQUALITY" />
					<xsd:enumeration value="INCLUDE" />
        </xsd:restriction>
      </xsd:simpleType>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="ColumnType">
    <xsd:attribute name="Name" type="xsd:string" use="required" />
    <xsd:attribute name="ColumnId" type="xsd:int" use="required">
      <ssp:annotation />
    </xsd:attribute>
  </xsd:complexType>
  <!-- 
   *****************************************
   **  
   **  Relational Operator related definitions
   **
   **
   **
   *****************************************
   -->
  <!-- Base class execution tree element -->
  <xsd:complexType name="QueryPlanType">
    <xsd:annotation>
			<xsd:documentation>
			New Runtime information:
			DegreeOfParallelism
			EffectiveDegreeOfParallelism: Max parallelism used by columnstore index build
			MemoryGrant (in kilobytes)
			ExclusiveProfileTimeActive:  true if the actual elapsed time (ActualElapsedms attribute)
				and the actual CPU time (ActualCPUms attribute) represent the time interval spent
				exclusively within the relational iterator.
			
			New compile time information:
			mem fractions
			CachedPlanSize (in kilobytes)
			CompileTime (in milliseconds)
			CompileCPU (in milliseconds)
			CompileMemory (in kilobytes)
			Parameter values used during query compilation
			NonParallelPlanReason		
			</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="InternalInfo" type="shp:InternalInfoType" minOccurs="0" maxOccurs="1">
        <ssp:annotation/>
      </xsd:element>
      <xsd:element name="OptimizationReplay" type="shp:OptimizationReplayType" minOccurs="0" maxOccurs="1">
        <ssp:annotation/>
      </xsd:element>
      <xsd:element name="ThreadStat" type="shp:ThreadStatType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="true" />
      </xsd:element>
      <xsd:element name="MissingIndexes" type="shp:MissingIndexesType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToStatementAs="true" />
      </xsd:element>
      <xsd:element name="GuessedSelectivity" type="shp:GuessedSelectivityType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="true" />
      </xsd:element>
      <xsd:element name="UnmatchedIndexes" type="shp:UnmatchedIndexesType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="true" />
      </xsd:element>
      <xsd:element name="Warnings" type="shp:WarningsType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="statementWarnings" />
      </xsd:element>
      <xsd:element name="MemoryGrantInfo" type="shp:MemoryGrantType" minOccurs="0" maxOccurs="1">
        <ssp:annotation  />
      </xsd:element>
      <xsd:element name="OptimizerHardwareDependentProperties" type="shp:OptimizerHardwareDependentPropertiesType" minOccurs="0" maxOccurs="1">
        <ssp:annotation  />
      </xsd:element>
      <xsd:element name="OptimizerStatsUsage" type="shp:OptimizerStatsUsageType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="true" />
      </xsd:element>
      <xsd:element name="TraceFlags" type="shp:TraceFlagListType" minOccurs="0" maxOccurs="2">
        <ssp:annotation bindToNodeAs="true" />
      </xsd:element>
      <xsd:element name="WaitStats" type="shp:WaitStatListType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="true" />
      </xsd:element>
      <xsd:element name="QueryTimeStats" type="shp:QueryExecTimeType" minOccurs="0" maxOccurs="1">
        <ssp:annotation />
      </xsd:element>
      <xsd:element name="RelOp" type="shp:RelOpType">
        <ssp:annotation />
      </xsd:element>
      <xsd:element name="ParameterList" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="parameter" />
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="DegreeOfParallelism" type="xsd:int" use="optional">
      <ssp:annotation category="Common" property="true" />
    </xsd:attribute>
    <xsd:attribute name="EffectiveDegreeOfParallelism" type="xsd:int" use="optional">
      <ssp:annotation category="Common" property="true" />
    </xsd:attribute>
    <xsd:attribute name="NonParallelPlanReason" type="xsd:string" use="optional">
      <ssp:annotation category="Common" property="true" />
    </xsd:attribute>
    <xsd:attribute name="DOPFeedbackAdjusted" type="shp:DOPFeedbackInfoType" use="optional">
      <ssp:annotation category="Common" property="true" />
    </xsd:attribute>
    <xsd:attribute name="MemoryGrant" type="xsd:unsignedLong" use="optional">
      <ssp:annotation category="Metrics" property="Memory Grant" />
    </xsd:attribute>
    <xsd:attribute name="CachedPlanSize" type="xsd:unsignedLong" use="optional">
      <ssp:annotation category="Common" property="true" />
    </xsd:attribute>
    <xsd:attribute name="CompileTime" type="xsd:unsignedLong" use="optional">
      <ssp:annotation category="Compile" property="true" />
    </xsd:attribute>
    <xsd:attribute name="CompileCPU" type="xsd:unsignedLong" use="optional">
      <ssp:annotation category="Compile" property="true" />
    </xsd:attribute>
    <xsd:attribute name="CompileMemory" type="xsd:unsignedLong" use="optional">
      <ssp:annotation category="Compile" property="true" />
    </xsd:attribute>
    <xsd:attribute name="UsePlan" type="xsd:boolean" use="optional">
      <ssp:annotation category="Common" property="true" />
    </xsd:attribute>
    <xsd:attribute name="ContainsInterleavedExecutionCandidates" type="xsd:boolean" use="optional">
      <ssp:annotation category="Common" property="true"/>
    </xsd:attribute>
    <xsd:attribute name="ContainsInlineScalarTsqlUdfs" type="xsd:boolean" use="optional">
      <ssp:annotation category="Common" property="true"/>
    </xsd:attribute>
		<xsd:attribute name="QueryVariantID" type="xsd:int" use="optional">
      <ssp:annotation category="Common" property="true"/>
    </xsd:attribute>
		<xsd:attribute name="DispatcherPlanHandle" type="xsd:string" use="optional">
      <ssp:annotation category="Common" property="true"/>
    </xsd:attribute>
		<xsd:attribute name="ExclusiveProfileTimeActive" type="xsd:boolean" use="optional">
      <ssp:annotation category="Common" property="true"/>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="GuessedSelectivityType">
    <xsd:sequence>
      <xsd:element name="Spatial" type="shp:ObjectType" minOccurs="1" maxOccurs="1">
        <ssp:annotation bindToNodeAs="guessed_selectivity_spatial" />
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="UnmatchedIndexesType">
    <xsd:sequence>
      <xsd:element name="Parameterization" type="shp:ParameterizationType" minOccurs="1" maxOccurs="1">
        <ssp:annotation  />
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="ParameterizationType">
    <xsd:sequence>
      <xsd:element name="Object" type="shp:ObjectType" minOccurs="1" maxOccurs="unbounded">
        <ssp:annotation bindToNodeAs="parameterization" />
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
	<!--
		1.
		Elements tag with the format
		<PDW>  <- This tag is a comment
		<Element>
		</PDW> <- This tag is a comment
		Represent Logical Operators dervied from PDW's estimated execution plan.

		e.g
		<PDW>  <- This tag is a comment
		<xsd:element name="Insert" type="shp:DMLOpType" />
		<xsd:element name="Join" type="shp:JoinType" />
		</PDW> <- This tag is a comment

		2.
		Elements tag with the format
		<Extended for PDW>  <- This tag is a comment
		<Element>
		</Extended for PDW> <- This tag is a comment
		Represent Operators that have a similar naming convention with that of PDW

		e.g
		New element have been added to UpdateType to allow it have DMLOpType features.
		New attribute have been added to TopType to allow it represent the location of the top.

		Note:
		These features are only present in PDW.
	-->
  <xsd:complexType name="RelOpType">
    <xsd:sequence>
      <xsd:element name="OutputList" type="shp:ColumnReferenceListType">
        <ssp:annotation bindToNodeAs="output" />
      </xsd:element>
      <xsd:element name="Warnings" type="shp:WarningsType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="nodeWarnings" />
      </xsd:element>
      <xsd:element name="MemoryFractions" type="shp:MemoryFractionsType" minOccurs="0" maxOccurs="1">
        <ssp:annotation />
      </xsd:element>
      <xsd:element name="RunTimeInformation" type="shp:RunTimeInformationType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="true" />
      </xsd:element>
      <xsd:element name="RunTimePartitionSummary" type="shp:RunTimePartitionSummaryType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="partition" />
      </xsd:element>
      <xsd:element name="InternalInfo" type="shp:InternalInfoType" minOccurs="0" maxOccurs="1" />
      <xsd:choice>
        <xsd:element name="AdaptiveJoin" type="shp:AdaptiveJoinType">
          <ssp:annotation />
        </xsd:element>
				<!--				PDW						-->
				<xsd:element name="Apply" type="shp:JoinType">
          <ssp:annotation />
        </xsd:element>
				<!--				/PDW					-->
        <xsd:element name="Assert" type="shp:FilterType">
          <ssp:annotation bindToNodeAs="nameset" />
        </xsd:element>
        <xsd:element name="BatchHashTableBuild" type="shp:BatchHashTableBuildType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="Bitmap" type="shp:BitmapType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="Collapse" type="shp:CollapseType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="ComputeScalar" type="shp:ComputeScalarType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="Concat" type="shp:ConcatType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="ConstantScan" type="shp:ConstantScanType">
          <ssp:annotation bindToNodeAs="const" />
        </xsd:element>
        <!--				PDW							-->
				<xsd:element name="ConstTableGet" type="shp:GetType">
          <ssp:annotation />
        </xsd:element>
				<!--				/PDW							-->
        <xsd:element name="CreateIndex" type="shp:CreateIndexType">
          <ssp:annotation />
        </xsd:element>
				<!--				PDW					-->
				<xsd:element name="Delete" type="shp:DMLOpType">
          <ssp:annotation />
        </xsd:element>
				<!--				/PDW					-->
        <xsd:element name="DeletedScan" type="shp:RowsetType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="Extension" type="shp:UDXType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="ExternalSelect" type="shp:ExternalSelectType">
          <ssp:annotation />
        </xsd:element>
				<xsd:element name="ExtExtractScan" type="shp:RemoteType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="Filter" type="shp:FilterType">
          <ssp:annotation bindToNodeAs="nameset" />
        </xsd:element>
        <xsd:element name="ForeignKeyReferencesCheck" type="shp:ForeignKeyReferencesCheckType">
          <ssp:annotation />
        </xsd:element>
				<!--				PDW					-->
				<xsd:element name="GbAgg" type="shp:GbAggType">
          <ssp:annotation />
        </xsd:element>
				<xsd:element name="GbApply" type="shp:GbApplyType">
          <ssp:annotation />
        </xsd:element>
				<!--				/PDW					-->
        <xsd:element name="Generic" type="shp:GenericType">
          <ssp:annotation />
        </xsd:element>
        <!--				PDW					-->
				<xsd:element name="Get" type="shp:GetType">
          <ssp:annotation />
        </xsd:element>
				<!--				/PDW					-->
        <xsd:element name="Hash" type="shp:HashType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="IndexScan" type="shp:IndexScanType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="InsertedScan" type="shp:RowsetType">
          <ssp:annotation />
        </xsd:element>
				<!--				PDW					-->
				<xsd:element name="Insert" type="shp:DMLOpType">
          <ssp:annotation />
        </xsd:element>
				<xsd:element name="Join" type="shp:JoinType">
          <ssp:annotation />
        </xsd:element>
				<xsd:element name="LocalCube" type="shp:LocalCubeType">
          <ssp:annotation />
        </xsd:element>
				<!--				/PDW					-->
        <xsd:element name="LogRowScan" type="shp:RelOpBaseType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="Merge" type="shp:MergeType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="MergeInterval" type="shp:SimpleIteratorOneChildType">
          <ssp:annotation />
        </xsd:element>
				<!--				PDW					-->
				<xsd:element name="Move" type="shp:MoveType">
          <ssp:annotation />
        </xsd:element>
				<!--				/PDW					-->

        <xsd:element name="NestedLoops" type="shp:NestedLoopsType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="OnlineIndex" type="shp:CreateIndexType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="Parallelism" type="shp:ParallelismType">
          <ssp:annotation bindToNodeAs="parallelism" />
        </xsd:element>
        <xsd:element name="ParameterTableScan" type="shp:RelOpBaseType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="PrintDataflow" type="shp:RelOpBaseType">
          <ssp:annotation />
        </xsd:element>
 				<!--				PDW					-->
				<xsd:element name="Project" type="shp:ProjectType">
          <ssp:annotation bindToNodeAs="remote" />
        </xsd:element>
				<!--				/PDW					-->
        <xsd:element name="Put" type="shp:PutType">
          <ssp:annotation bindToNodeAs="remote" />
        </xsd:element>
        <xsd:element name="RemoteFetch" type="shp:RemoteFetchType">
          <ssp:annotation bindToNodeAs="remote" />
        </xsd:element>
        <xsd:element name="RemoteModify" type="shp:RemoteModifyType">
          <ssp:annotation bindToNodeAs="remote" />
        </xsd:element>
        <xsd:element name="RemoteQuery" type="shp:RemoteQueryType">
          <ssp:annotation bindToNodeAs="remote" />
        </xsd:element>
        <xsd:element name="RemoteRange" type="shp:RemoteRangeType">
          <ssp:annotation bindToNodeAs="remote" />
        </xsd:element>
        <xsd:element name="RemoteScan" type="shp:RemoteType">
          <ssp:annotation bindToNodeAs="remote" />
        </xsd:element>
        <xsd:element name="RowCountSpool" type="shp:SpoolType">
          <ssp:annotation  />
        </xsd:element>
        <xsd:element name="ScalarInsert" type="shp:ScalarInsertType">
          <ssp:annotation  />
        </xsd:element>
        <xsd:element name="Segment" type="shp:SegmentType">
          <ssp:annotation bindToNodeAs="segment" />
        </xsd:element>
        <xsd:element name="Sequence" type="shp:SequenceType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="SequenceProject" type="shp:ComputeScalarType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="SimpleUpdate" type="shp:SimpleUpdateType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="Sort" type="shp:SortType">
          <ssp:annotation bindToNodeAs="nameset" />
        </xsd:element>
        <xsd:element name="Split" type="shp:SplitType">
          <ssp:annotation bindToNodeAs="split" />
        </xsd:element>
        <xsd:element name="Spool" type="shp:SpoolType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="StreamAggregate" type="shp:StreamAggregateType">
          <ssp:annotation bindToNodeAs="nameset" />
        </xsd:element>
        <xsd:element name="Switch" type="shp:SwitchType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="TableScan" type="shp:TableScanType">
          <ssp:annotation bindToNodeAs="nameset" />
        </xsd:element>
        <xsd:element name="TableValuedFunction" type="shp:TableValuedFunctionType">
          <ssp:annotation bindToNodeAs="nameset"/>
        </xsd:element>
        <xsd:element name="Top" type="shp:TopType">
          <ssp:annotation bindToNodeAs="nameset" />
        </xsd:element>
        <xsd:element name="TopSort" type="shp:TopSortType">
          <ssp:annotation bindToNodeAs="nameset" />
        </xsd:element>
        <xsd:element name="Update" type="shp:UpdateType">
          <ssp:annotation />
        </xsd:element>
				<xsd:element name="Update" type="shp:UpdateType">
          <ssp:annotation />
        </xsd:element>
				<!--				PDW					-->
				<xsd:element name="Union" type="shp:ConcatType">
          <ssp:annotation />
        </xsd:element>
				<xsd:element name="UnionAll" type="shp:ConcatType">
          <ssp:annotation />
        </xsd:element>
				<!--				/PDW					-->
        <xsd:element name="WindowSpool" type="shp:WindowType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="WindowAggregate" type="shp:WindowAggregateType">
          <ssp:annotation />
        </xsd:element>
        <xsd:element name="XcsScan" type="shp:XcsScanType">
          <ssp:annotation />
        </xsd:element>
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="AvgRowSize" type="xsd:double" use="required">
      <ssp:annotation property="Average Row Size" category="Metrics" />
    </xsd:attribute>
    <xsd:attribute name="EstimateCPU" type="xsd:double" use="required">
      <ssp:annotation estimated="CPU" category="Metrics" setToStatement="true" />
    </xsd:attribute>
    <xsd:attribute name="EstimateIO" type="xsd:double" use="required">
      <ssp:annotation estimated="IO" category="Metrics" setToStatement="true" />
    </xsd:attribute>
    <xsd:attribute name="EstimateRebinds" type="xsd:double" use="required">
      <ssp:annotation estimated="Rebinds" category="Metrics" />
    </xsd:attribute>
    <xsd:attribute name="EstimateRewinds" type="xsd:double" use="required">
      <ssp:annotation estimated="Rewinds" category="Metrics" />
    </xsd:attribute>
    <xsd:attribute name="EstimatedExecutionMode" type="shp:ExecutionModeType" use="optional">
      <ssp:annotation estimated="Execution Mode" category="Metrics" />
    </xsd:attribute>
    <xsd:attribute name="GroupExecuted" type="xsd:boolean" use="optional">
      <ssp:annotation flag="true" />
    </xsd:attribute>
    <xsd:attribute name="EstimateRows" type="xsd:double" use="required">
      <ssp:annotation estimated="Rows" category="Metrics" />
    </xsd:attribute>
 		<xsd:attribute name="EstimateRowsWithoutRowGoal" type="xsd:double" use="optional">
      <ssp:annotation estimated="Rows" category="Metrics" />
    </xsd:attribute>
    <xsd:attribute name="EstimatedRowsRead" type="xsd:double" use="optional">
      <ssp:annotation estimated="Rows Read" category="Metrics" />
    </xsd:attribute>
    <xsd:attribute name="LogicalOp" type="shp:LogicalOpType" use="required">
      <ssp:annotation subTitle="true" property="Logical Operation" category="General" />
    </xsd:attribute>
    <xsd:attribute name="NodeId" type="xsd:int" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="Parallel" type="xsd:boolean" use="required">
      <ssp:annotation flag="true" />
    </xsd:attribute>
    <xsd:attribute name="RemoteDataAccess" type="xsd:boolean" use="optional">
      <ssp:annotation flag="true" />
    </xsd:attribute>
    <xsd:attribute name="Partitioned" type="xsd:boolean" use="optional">
      <ssp:annotation flag="true" />
    </xsd:attribute>
    <xsd:attribute name="PhysicalOp" type="shp:PhysicalOpType" use="required">
      <ssp:annotation title="true" property="Physical Operation" category="General" />
    </xsd:attribute>
    <xsd:attribute name="IsAdaptive" type="xsd:boolean" use="optional">
      <ssp:annotation flag="true" />
    </xsd:attribute>
    <xsd:attribute name="AdaptiveThresholdRows" type="xsd:double" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="EstimatedTotalSubtreeCost" type="xsd:double" use="required">
      <ssp:annotation estimated="Total Subtree Cost" category="Metrics" />
    </xsd:attribute>
    <xsd:attribute name="TableCardinality" type="xsd:double" use="optional">
      <ssp:annotation property="true" category="Metrics" />
    </xsd:attribute>
    <xsd:attribute name="StatsCollectionId" type="xsd:unsignedLong" use="optional">
      <ssp:annotation property="true" category="General" />
    </xsd:attribute>
    <xsd:attribute name="EstimatedJoinType" type="shp:PhysicalOpType" use="optional">
      <ssp:annotation estimated="Join Type" category="Metrics" />
    </xsd:attribute>
		<xsd:attribute name="HyperScaleOptimizedQueryProcessing" type="xsd:string" use="optional">
      <ssp:annotation estimated="Hyper Scale Optimized Query Processing" category="Metrics" />
    </xsd:attribute>
		<xsd:attribute name="HyperScaleOptimizedQueryProcessingUnusedReason" type="xsd:string" use="optional">
      <ssp:annotation estimated="Hyper Scale Optimized Query Processing Unused Reason" category="Metrics" />
    </xsd:attribute>
		<!-- For PDW cost Operators -->
		<xsd:attribute name="PDWAccumulativeCost" type="xsd:double" use="optional">
      <ssp:annotation estimated="PDW Accumulative Cost" category="Metrics" />
    </xsd:attribute>
    <ssp:annotation planNode="true" />
  </xsd:complexType>
  <xsd:complexType name="RelOpBaseType">
    <xsd:sequence>
      <xsd:element name="DefinedValues" type="shp:DefinedValuesListType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="defined_values" />
      </xsd:element>
      <xsd:element name="InternalInfo" type="shp:InternalInfoType" minOccurs="0" maxOccurs="1" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="AdaptiveJoinType">
    <xsd:annotation>
      <xsd:documentation>
				The Adaptive Join element replaces a adaptive concat with Hash Join and Nested loops as inputs. This element
				will have 3 inputs the two children of the HJ and the inner child of the NLJ. We append the required HJ and NLJ properties to the new 
				AdaptiveJoin showplan element.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="HashKeysBuild" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="build_hash" />
          </xsd:element>
          <xsd:element name="HashKeysProbe" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="probe_hash" />
          </xsd:element>
          <xsd:element name="BuildResidual" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="build_hash" />
          </xsd:element>
          <xsd:element name="ProbeResidual" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="probe_hash" />
          </xsd:element>
          <xsd:element name="StarJoinInfo" type="shp:StarJoinInfoType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="starjoin" />
          </xsd:element>
          <xsd:element name="Predicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="predicate" />
          </xsd:element>
          <xsd:element name="PassThru" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="passthru" />
          </xsd:element>
          <xsd:element name="OuterReferences" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="outer_references" />
          </xsd:element>
          <xsd:element name="PartitionId" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="partition" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType" minOccurs="3" maxOccurs="3">
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="BitmapCreator" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="Optimized" type="xsd:boolean" use="required">
          <ssp:annotation flag="true" />
        </xsd:attribute>
 				<xsd:attribute name="WithOrderedPrefetch" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
				<xsd:attribute name="WithUnorderedPrefetch" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ForeignKeyReferencesCheckType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="RelOp" type="shp:RelOpType" minOccurs="1" maxOccurs="1" />
          <xsd:element name="ForeignKeyReferenceCheck" type="shp:ForeignKeyReferenceCheckType" minOccurs="1" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="ForeignKeyReferencesCount" type="xsd:int" use="optional">
          <ssp:annotation flag="true" flagValue="Foreign Key Count: ${ForeignKeyReferencesCount}" />
        </xsd:attribute>
        <xsd:attribute name="NoMatchingIndexCount" type="xsd:int" use="optional">
          <ssp:annotation flag="true" flagValue="No Matching Count: ${NoMatchingIndexCount}" />
        </xsd:attribute>
        <xsd:attribute name="PartialMatchingIndexCount" type="xsd:int" use="optional">
          <ssp:annotation flag="true" flagValue="Partial Count: ${PartialMatchingIndexCount}" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ForeignKeyReferenceCheckType">
    <xsd:sequence>
			<xsd:element name="IndexScan" type="shp:IndexScanType" minOccurs="1" maxOccurs="1" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="SimpleIteratorOneChildType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
					<xsd:element name="RelOp" type="shp:RelOpType" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="FilterType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="RelOp" type="shp:RelOpType" />
          <xsd:element name="Predicate" type="shp:ScalarExpressionType">
            <ssp:annotation bindToNodeAs="predicate" />
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="StartupExpression" type="xsd:boolean" use="required">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ConstantScanType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="Values" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
              <xsd:sequence>
								<xsd:element name="Row" type="shp:ScalarExpressionListType" minOccurs="0" maxOccurs="unbounded" />
              </xsd:sequence>
            </xsd:complexType>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RowsetType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="Object" type="shp:ObjectType" minOccurs="1" maxOccurs="unbounded">
            <ssp:annotation bindToNodeAs="rowset" />
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TableScanType">
    <xsd:annotation>
			<xsd:documentation source="TableScan reads from a table and is able to apply a filter predicate" />
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="shp:RowsetType">
        <xsd:sequence>
          <xsd:element name="Predicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="predicate" />
          </xsd:element>
          <xsd:element name="PartitionId" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="partition" />
          </xsd:element>
          <xsd:element name="IndexedViewInfo" type="shp:IndexedViewInfoType" minOccurs="0" maxOccurs="1">
            <ssp:annotation />
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="Ordered" type="xsd:boolean" use="required">
          <ssp:annotation flag="true"/>
        </xsd:attribute>
        <xsd:attribute name="ForcedIndex" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true"/>
        </xsd:attribute>
        <xsd:attribute name="ForceScan" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="NoExpandHint" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="Storage" type="shp:StorageType" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
	<xsd:complexType name="XcsScanType">
		<xsd:annotation>
			<xsd:documentation source="XcsScan reads from an externally managed table and is able to apply a filter predicate. It has a child tree which provides the metadata for the external files that compose the table." />
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="shp:RowsetType">
				<xsd:sequence>
					<xsd:element name="Predicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="predicate" />
          </xsd:element>
					<xsd:element name="PartitionId" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="partition" />
          </xsd:element>
					<xsd:element name="IndexedViewInfo" type="shp:IndexedViewInfoType" minOccurs="0" maxOccurs="1">
            <ssp:annotation/>
          </xsd:element>
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="1" maxOccurs="1" />
				</xsd:sequence>
				<xsd:attribute name="Ordered" type="xsd:boolean" use="required">
          <ssp:annotation flag="true" />
        </xsd:attribute>
				<xsd:attribute name="ForcedIndex" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
				<xsd:attribute name="ForceScan" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
				<xsd:attribute name="NoExpandHint" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
				<xsd:attribute name="Storage" type="shp:StorageType" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
			</xsd:extension>
		</xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IndexScanType">
    <xsd:complexContent>
      <xsd:extension base="shp:RowsetType">
        <xsd:sequence>
          <xsd:element name="SeekPredicates" type="shp:SeekPredicatesType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="seek_predicate" />
          </xsd:element>
          <xsd:element name="Predicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="predicate" />
          </xsd:element>
          <xsd:element name="PartitionId" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="partition" />
          </xsd:element>
          <xsd:element name="IndexedViewInfo" type="shp:IndexedViewInfoType" minOccurs="0" maxOccurs="1">
            <ssp:annotation />
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="Lookup" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="Ordered" type="xsd:boolean" use="required">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="ScanDirection" type="shp:OrderType" use="optional">
          <ssp:annotation flag="true" flagValue="${ScanDirection}"/>
        </xsd:attribute>
        <xsd:attribute name="ForcedIndex" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="ForceSeek" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" flagValue="Force Seek (${ForceSeekColumnCount} columns)"/>
        </xsd:attribute>
        <xsd:attribute name="ForceSeekColumnCount" type="xsd:int" use="optional">
        </xsd:attribute>
        <xsd:attribute name="ForceScan" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="NoExpandHint" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="Storage" type="shp:StorageType" use="optional">
          <ssp:annotation flag="true" flagValue="${Storage}" flagDefault="Row Store" />
        </xsd:attribute>
        <xsd:attribute name="DynamicSeek" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" flagValue="${DynamicSeek}"/>
        </xsd:attribute>
        <xsd:attribute name="SBSFileUrl" type="xsd:string" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TableValuedFunctionType">
		<xsd:annotation>
			<xsd:documentation>
				Typical user defined table valued function doesn't have a relational child element. If a relational child
				is present then the operator is a special internal table valued function that hosts native code.
			</xsd:documentation>
		</xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="Object" type="shp:ObjectType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="tablevaluefunction" />
          </xsd:element>
          <xsd:element name="Predicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="predicate" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="1"/>
          <xsd:element name="ParameterList" type="shp:ScalarExpressionListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation  />
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HashType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="HashKeysBuild" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="build_hash" />
          </xsd:element>
          <xsd:element name="HashKeysProbe" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="probe_hash" />
          </xsd:element>
          <xsd:element name="BuildResidual" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="build_hash" />
          </xsd:element>
          <xsd:element name="ProbeResidual" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="probe_hash" />
          </xsd:element>
          <xsd:element name="StarJoinInfo" type="shp:StarJoinInfoType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="starjoin" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType" minOccurs="1" maxOccurs="2"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="BitmapCreator" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ComputeScalarType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
					<xsd:element name="RelOp" type="shp:RelOpType" />
        </xsd:sequence>
        <xsd:attribute name="ComputeSequence" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ParallelismType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="PartitionColumns" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="partition" />
          </xsd:element>
          <xsd:element name="OrderBy" type="shp:OrderByType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="orderby" />
          </xsd:element>
          <xsd:element name="HashKeys" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="hashkeys" />
          </xsd:element>
          <xsd:element name="ProbeColumn" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="probe" />
          </xsd:element>
          <xsd:element name="Predicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="predicate" />
          </xsd:element>
          <xsd:element name="Activation" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="Object" type="shp:ObjectType" minOccurs="0" maxOccurs="1">
                  <ssp:annotation bindToNodeAs="parallelism_activation" />
                </xsd:element>
              </xsd:sequence>
              <xsd:attribute name="Type" use="required">
                <xsd:simpleType>
                  <xsd:restriction base="xsd:string">
										<xsd:enumeration value="CloneLocation" />
										<xsd:enumeration value="Resource" />
										<xsd:enumeration value="SingleBrick" />
										<xsd:enumeration value="Region" />
                  </xsd:restriction>
                </xsd:simpleType>
              </xsd:attribute>
							<xsd:attribute name="FragmentElimination" use="optional"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="BrickRouting" minOccurs="0" maxOccurs="1">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="Object" type="shp:ObjectType" minOccurs="0" maxOccurs="1">
                  <ssp:annotation bindToNodeAs="parallelism_brick_routing" />
                </xsd:element>
                <xsd:element name="FragmentIdColumn" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
                  <ssp:annotation bindToNodeAs="fragment_id" />
                </xsd:element>
              </xsd:sequence>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="PartitioningType" type="shp:PartitionType" use="optional">
          <ssp:annotation flag="true" flagValue="${PartitioningType}" />
        </xsd:attribute>
        <xsd:attribute name="Remoting" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="LocalParallelism" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="InRow" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StreamAggregateType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="GroupBy" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="groupby" />
          </xsd:element>
          <xsd:element name="RollupInfo" type="shp:RollupInfoType" minOccurs="0" maxOccurs="1">
            <ssp:annotation />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType"></xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SortType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="OrderBy" type="shp:OrderByType">
            <ssp:annotation bindToNodeAs="orderby" />
          </xsd:element>
          <xsd:element name="PartitionId" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="partition" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="Distinct" type="xsd:boolean" use="required">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BitmapType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="HashKeys" type="shp:ColumnReferenceListType">
            <ssp:annotation bindToNodeAs="hashkeys" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CollapseType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="GroupBy" type="shp:ColumnReferenceListType">
            <ssp:annotation bindToNodeAs="groupby" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ConcatType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="2" maxOccurs="unbounded" />
          <!-- Uses DefinedValues to show union columns -->
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SwitchType">
    <xsd:complexContent>
      <xsd:extension base="shp:ConcatType">
        <xsd:sequence>
          <xsd:element name="Predicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="predicate" />
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="MergeType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="InnerSideJoinColumns" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="join_inside" />
          </xsd:element>
          <xsd:element name="OuterSideJoinColumns" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="join_outside" />
          </xsd:element>
          <xsd:element name="Residual" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="residual" />
          </xsd:element>
          <xsd:element name="PassThru" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="passthru" />
          </xsd:element>
          <xsd:element name="StarJoinInfo" type="shp:StarJoinInfoType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="starjoin" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType" minOccurs="2" maxOccurs="2">
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="ManyToMany" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NestedLoopsType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="Predicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="predicate" />
          </xsd:element>
          <xsd:element name="PassThru" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="passthru" />
          </xsd:element>
          <xsd:element name="OuterReferences" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="outer_references" />
          </xsd:element>
          <xsd:element name="PartitionId" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="partition" />
          </xsd:element>
          <xsd:element name="ProbeColumn" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="probe" />
          </xsd:element>
          <xsd:element name="StarJoinInfo" type="shp:StarJoinInfoType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="starjoin" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType" minOccurs="2" maxOccurs="2"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="Optimized" type="xsd:boolean" use="required">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="WithOrderedPrefetch" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="WithUnorderedPrefetch" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SegmentType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="GroupBy" type="shp:ColumnReferenceListType">
            <ssp:annotation bindToNodeAs="groupby" />
          </xsd:element>
          <xsd:element name="SegmentColumn" type="shp:SingleColumnReferenceType">
            <ssp:annotation bindToNodeAs="segment" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType"></xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SequenceType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="RelOp" type="shp:RelOpType" minOccurs="2" maxOccurs="unbounded" />
        </xsd:sequence>
 				<xsd:attribute name="IsGraphDBTransitiveClosure" type="xsd:boolean" use="optional" />
				<xsd:attribute name="GraphSequenceIdentifier" type="xsd:integer" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SplitType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="ActionColumn" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="action" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TopType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="TieColumns" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="tie" />
          </xsd:element>
					<xsd:element name="OffsetExpression" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="TopExpression" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="RelOp" type="shp:RelOpType" />
				</xsd:sequence>
				<xsd:attribute name="RowCount" type="xsd:boolean" use="optional" />
				<xsd:attribute name="Rows" type="xsd:int" use="optional" />
				<xsd:attribute name="IsPercent" type="xsd:boolean" use="optional" />
				<xsd:attribute name="WithTies" type="xsd:boolean" use="optional" />
				<!--					Extended for PDW 						-->
				<xsd:attribute name="TopLocation" type="xsd:string" use="optional" />
				<!--					/Extended for PDW 						-->
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UDXType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:element name="UsedUDXColumns" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="udx" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="1"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="UDXName" type="xsd:string" use="required">
          <ssp:annotation nameSet="true"/>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="WindowType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="WindowAggregateType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PutType">
    <xsd:complexContent>
      <xsd:extension base="shp:RemoteQueryType">
        <xsd:sequence>
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
				<!--			Extended for PDW							-->
				<xsd:attribute name="IsExternallyComputed" type="xsd:boolean" use="optional" />
				<!--			/Extended for PDW							-->
        <xsd:attribute name="ShuffleType" type="xsd:string" use="optional" />
        <xsd:attribute name="ShuffleColumn" type="xsd:string" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SimpleUpdateType">
    <xsd:complexContent>
      <xsd:extension base="shp:RowsetType">
        <xsd:sequence>
          <xsd:choice>
            <xsd:element name="SeekPredicate" type="shp:SeekPredicateType" minOccurs="0" maxOccurs="1">
              <ssp:annotation bindToNodeAs="seek_predicate" />
            </xsd:element>
            <xsd:element name="SeekPredicateNew" type="shp:SeekPredicateNewType" minOccurs="0" maxOccurs="1">
              <ssp:annotation bindToNodeAs="seek_predicate" />
            </xsd:element>
          </xsd:choice>
          <xsd:element name="SetPredicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="set_predicate" />
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="DMLRequestSort" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SetPredicateElementType">
    <xsd:complexContent>
      <xsd:extension base="shp:ScalarExpressionType">
				<xsd:attribute name="SetPredicateType" type="shp:SetPredicateType" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UpdateType">
    <xsd:complexContent>
      <xsd:extension base="shp:RowsetType">
        <xsd:sequence>
          <xsd:element name="SetPredicate" type="shp:SetPredicateElementType" minOccurs="0" maxOccurs="2">
            <ssp:annotation bindToNodeAs="set_predicate" />
          </xsd:element>
          <xsd:element name="ProbeColumn" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="probe" />
          </xsd:element>
          <xsd:element name="ActionColumn" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="action" />
          </xsd:element>
          <xsd:element name="OriginalActionColumn" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="original_action" />
          </xsd:element>
 					<!--			Extended for PDW							-->
					<xsd:element name="AssignmentMap" type="shp:AssignmentMapType" minOccurs="0" maxOccurs="1">
            <ssp:annotation/>
          </xsd:element>
					<xsd:element name="SourceTable" type="shp:ParameterizationType" minOccurs="0" maxOccurs="1">
            <ssp:annotation/>
          </xsd:element>
					<xsd:element name="TargetTable" type="shp:ParameterizationType" minOccurs="0" maxOccurs="1">
            <ssp:annotation/>
          </xsd:element>
					<!--			/Extended for PDW							-->
					<xsd:element name="RelOp" type="shp:RelOpType" />
        </xsd:sequence>
        <xsd:attribute name="WithOrderedPrefetch" type="xsd:boolean" use="optional">
          <ssp:annotation flags="true" />
        </xsd:attribute>
        <xsd:attribute name="WithUnorderedPrefetch" type="xsd:boolean" use="optional">
          <ssp:annotation flags="true" />
        </xsd:attribute>
        <xsd:attribute name="DMLRequestSort" type="xsd:boolean" use="optional">
          <ssp:annotation flags="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CreateIndexType">
    <xsd:complexContent>
      <xsd:extension base="shp:RowsetType">
        <xsd:sequence>
					<xsd:element name="RelOp" type="shp:RelOpType" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SpoolType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
          <xsd:choice>
            <xsd:element name="SeekPredicate" type="shp:SeekPredicateType" minOccurs="0" maxOccurs="1">
              <ssp:annotation bindToNodeAs="seek_predicate" />
            </xsd:element>
            <xsd:element name="SeekPredicateNew" type="shp:SeekPredicateNewType" minOccurs="0" maxOccurs="1">
              <ssp:annotation bindToNodeAs="seek_predicate" />
            </xsd:element>
          </xsd:choice>
          <xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="1"></xsd:element>
        </xsd:sequence>
        <xsd:attribute name="Stack" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
        <xsd:attribute name="PrimaryNodeId" type="xsd:int" use="optional">
          <ssp:annotation flag="true" flagValue="Primary Node ID: ${PrimaryNodeId}"/>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BatchHashTableBuildType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
					<xsd:element name="RelOp" type="shp:RelOpType" />
        </xsd:sequence>
        <xsd:attribute name="BitmapCreator" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ScalarInsertType">
    <xsd:complexContent>
      <xsd:extension base="shp:RowsetType">
        <xsd:sequence>
          <xsd:element name="SetPredicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="set_predicate" />
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="DMLRequestSort" type="xsd:boolean" use="optional">
          <ssp:annotation flag="true" />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TopSortType">
    <xsd:complexContent>
      <xsd:extension base="shp:SortType">
				<xsd:attribute name="Rows" type="xsd:int" use="required" />
				<xsd:attribute name="WithTies" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RemoteType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:attribute name="RemoteDestination" type="xsd:string" use="optional" />
        <xsd:attribute name="RemoteSource" type="xsd:string" use="optional">
          <ssp:annotation />
        </xsd:attribute>
        <xsd:attribute name="RemoteObject" type="xsd:string" use="optional">
          <ssp:annotation />
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RemoteRangeType">
    <xsd:complexContent>
      <xsd:extension base="shp:RemoteType">
        <xsd:sequence>
          <xsd:element name="SeekPredicates" type="shp:SeekPredicatesType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="seek_predicate" />
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RemoteFetchType">
    <xsd:complexContent>
      <xsd:extension base="shp:RemoteType">
        <xsd:sequence>
          <xsd:element name="RelOp" type="shp:RelOpType" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RemoteModifyType">
    <xsd:complexContent>
      <xsd:extension base="shp:RemoteType">
        <xsd:sequence>
          <xsd:element name="SetPredicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1">
            <ssp:annotation bindToNodeAs="set_predicate" />
          </xsd:element>
          <xsd:element name="RelOp" type="shp:RelOpType" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RemoteQueryType">
    <xsd:complexContent>
      <xsd:extension base="shp:RemoteType">
				<xsd:attribute name="RemoteQuery" type="xsd:string" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GenericType">
    <xsd:complexContent>
      <xsd:extension base="shp:RelOpBaseType">
        <xsd:sequence>
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
	<!-- 			 PDW       -->
  <xsd:complexType name="ResourceEstimateType">
    <xsd:attribute name="NodeCount" type="xsd:unsignedLong" use="optional" />
    <xsd:attribute name="Dop" type="xsd:double" use="optional" />
    <xsd:attribute name="MemoryInBytes" type="xsd:double" use="optional" />
    <xsd:attribute name="DiskWrittenInBytes" type="xsd:double" use="optional" />
    <xsd:attribute name="Scalable" type="xsd:boolean" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="MoveType">
		<xsd:complexContent>
			<xsd:extension base="shp:RelOpBaseType">
				<xsd:sequence>
					<xsd:element name="DistributionKey" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="ResourceEstimate" type="shp:ResourceEstimateType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="unbounded" />
				</xsd:sequence>
				<xsd:attribute name="MoveType" type="xsd:string" use="optional" />
				<xsd:attribute name="DistributionType" type="xsd:string" use="optional" />
				<xsd:attribute name="IsDistributed" type="xsd:boolean" use="optional" />
				<xsd:attribute name="IsExternal" type="xsd:boolean" use="optional" />
				<xsd:attribute name="IsFull" type="xsd:boolean" use="optional" />
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ExternalSelectType">
		<xsd:complexContent>
			<xsd:extension base="shp:RelOpBaseType">
					<xsd:sequence>
						<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="unbounded" />
					</xsd:sequence>
				<xsd:attribute name="MaterializeOperation" type="xsd:string" use="optional" />
				<xsd:attribute name="DistributionType" type="xsd:string" use="optional" />
				<xsd:attribute name="IsDistributed" type="xsd:boolean" use="optional" />
				<xsd:attribute name="IsExternal" type="xsd:boolean" use="optional" />
				<xsd:attribute name="IsFull" type="xsd:boolean" use="optional" />
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="ProjectType">
		<xsd:complexContent>
			<xsd:extension base="shp:RelOpBaseType">
				<xsd:sequence>
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="unbounded" />
				</xsd:sequence>
				<xsd:attribute name="IsNoOp" type="xsd:boolean" use="optional" />
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="JoinType">
		<xsd:complexContent>
			<xsd:extension base="shp:RelOpBaseType">
				<xsd:sequence>
					<xsd:element name="Predicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="unbounded" />
					<xsd:element name="Probe" type="shp:SingleColumnReferenceType" minOccurs="0" maxOccurs="unbounded" />
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="unbounded" />
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="GbApplyType">
		<xsd:complexContent>
			<xsd:extension base="shp:RelOpBaseType">
				<xsd:sequence>
					<xsd:element name="Predicate" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="unbounded" />
					<xsd:element name="AggFunctions" type="shp:DefinedValuesListType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="unbounded" />
				</xsd:sequence>
				<xsd:attribute name="JoinType" type="xsd:string" use="optional" />
				<xsd:attribute name="AggType" type="xsd:string" use="optional" />
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="GbAggType">
		<xsd:complexContent>
			<xsd:extension base="shp:RelOpBaseType">
				<xsd:sequence>
					<xsd:element name="GroupBy" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="AggFunctions" type="shp:DefinedValuesListType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="unbounded" />
				</xsd:sequence>
				<xsd:attribute name="IsScalar" type="xsd:boolean" use="optional" />
				<xsd:attribute name="AggType" type="xsd:string" use="optional" />
				<xsd:attribute name="HintType" type="xsd:string" use="optional" />
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="GroupingSetReferenceType">
		<xsd:attribute name="Value" type="xsd:string" use="required"/>
	</xsd:complexType>
	<xsd:complexType name="GroupingSetListType">
		<xsd:sequence>
			<xsd:element name="GroupingSet" type="shp:GroupingSetReferenceType" minOccurs="0" maxOccurs="unbounded" />
		</xsd:sequence>
	</xsd:complexType>
	<xsd:complexType name="LocalCubeType">
		<xsd:complexContent>
			<xsd:extension base="shp:RelOpBaseType">
				<xsd:sequence>
					<xsd:element name="GroupBy" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="GroupingSets" type="shp:GroupingSetListType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="unbounded" />
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<!-- 			 /PDW       -->
	<!-- 
   *****************************************
   **
   **  Data Modification Language Operator related definitions (PDW)
   **
   **
   **
   *****************************************
   -->
	<xsd:complexType name="DMLOpType">
		<xsd:complexContent>
			<xsd:extension base="shp:RelOpBaseType">
				<xsd:sequence>
					<xsd:element name="AssignmentMap" type="shp:AssignmentMapType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="SourceTable" type="shp:ParameterizationType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="TargetTable" type="shp:ParameterizationType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="unbounded" />
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="AssignmentMapType">
		<xsd:sequence>
			<xsd:element name="Assign" type="shp:AssignType" minOccurs="0" maxOccurs="unbounded"/>
		</xsd:sequence>
	</xsd:complexType>
	<!--
   *****************************************
   **
   **  Scan Operator related definitions (PDW)
   **
   **
   **
   *****************************************
   -->
   	<xsd:complexType name="GetType">
		<xsd:complexContent>
			<xsd:extension base="shp:RelOpBaseType">
				<xsd:sequence>
					<xsd:element name="Bookmarks" type="shp:ColumnReferenceListType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="OutputColumns" type="shp:OutputColumnsType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="GeneratedData" type="shp:ScalarExpressionListType" minOccurs="0" maxOccurs="1" />
					<xsd:element name="RelOp" type="shp:RelOpType" minOccurs="0" maxOccurs="unbounded" />
				</xsd:sequence>
				<xsd:attribute name="NumRows" type="xsd:int" use="optional" />
        <xsd:attribute name="IsExternal" type="xsd:boolean" use="optional" />
        <xsd:attribute name="IsDistributed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="IsHashDistributed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="IsReplicated" type="xsd:boolean" use="optional" />
        <xsd:attribute name="IsRoundRobin" type="xsd:boolean" use="optional" />
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	<xsd:complexType name="OutputColumnsType">
		<xsd:sequence>
			<xsd:element name="DefinedValues" type="shp:DefinedValuesListType" minOccurs="0" maxOccurs="1" />
			<xsd:element name="Object" type="shp:ObjectType" minOccurs="0" maxOccurs="unbounded" />
		</xsd:sequence>
	</xsd:complexType>
  <!-- 
   *****************************************
   **  
   **  Scalar Operator related definitions
   **
   **
   **
   *****************************************
   -->
  <xsd:complexType name="ScalarType">
    <xsd:annotation>
			<xsd:documentation>Scalar expression. If root of scalar tree contains semantically equivalent string representation of entire expression</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice>
				<xsd:element name="Aggregate" type="shp:AggregateType" />
				<xsd:element name="Arithmetic" type="shp:ArithmeticType" />
				<xsd:element name="Assign" type="shp:AssignType" />
				<xsd:element name="Compare" type="shp:CompareType" />
				<xsd:element name="Const" type="shp:ConstType" />
				<xsd:element name="Convert" type="shp:ConvertType" />
				<xsd:element name="Identifier" type="shp:IdentType" />
				<xsd:element name="IF" type="shp:ConditionalType" />
				<xsd:element name="Intrinsic" type="shp:IntrinsicType" />
				<xsd:element name="Logical" type="shp:LogicalType" />
				<xsd:element name="MultipleAssign" type="shp:MultAssignType" />
				<xsd:element name="ScalarExpressionList" type="shp:ScalarExpressionListType" />
				<xsd:element name="Sequence" type="shp:ScalarSequenceType" />
				<xsd:element name="Subquery" type="shp:SubqueryType" />
				<xsd:element name="UDTMethod" type="shp:UDTMethodType" />
				<xsd:element name="UserDefinedAggregate" type="shp:UDAggregateType" />
				<xsd:element name="UserDefinedFunction" type="shp:UDFType" />
      </xsd:choice>
			<xsd:element name="InternalInfo" type="shp:InternalInfoType" minOccurs="0" maxOccurs="1" />
    </xsd:sequence>
		<xsd:attribute name="ScalarString" type="xsd:string" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="ScalarExpressionType">
    <xsd:sequence>
			<xsd:element name="ScalarOperator" type="shp:ScalarType" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="ScalarExpressionListType">
    <xsd:sequence>
			<xsd:element name="ScalarOperator" type="shp:ScalarType" minOccurs="1" maxOccurs="unbounded" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="ConstType">
		<xsd:attribute name="ConstValue" type="xsd:string" use="required" />
  </xsd:complexType>
  <xsd:complexType name="IdentType">
    <xsd:sequence>
			<xsd:element name="ColumnReference" type="shp:ColumnReferenceType" minOccurs="0" maxOccurs="1" />
    </xsd:sequence>
		<xsd:attribute name="Table" type="xsd:string" />
  </xsd:complexType>
  <xsd:complexType name="CompareType">
    <xsd:sequence>
			<xsd:element name="ScalarOperator" type="shp:ScalarType" minOccurs="1" maxOccurs="2" />
    </xsd:sequence>
		<xsd:attribute name="CompareOp" type="shp:CompareOpType" use="required" />
  </xsd:complexType>
  <xsd:complexType name="ConvertType">
    <xsd:sequence>
			<xsd:element name="Style" type="shp:ScalarExpressionType" minOccurs="0" maxOccurs="1" />
			<xsd:element name="ScalarOperator" type="shp:ScalarType" />
    </xsd:sequence>
    <xsd:attribute name="DataType" type="xsd:string" use="required" />
    <xsd:attribute name="Length" type="xsd:int" use="optional" />
    <xsd:attribute name="Precision" type="xsd:int" use="optional" />
    <xsd:attribute name="Scale" type="xsd:int" use="optional" />
    <xsd:attribute name="Style" type="xsd:int" use="required">
      <ssp:annotation altName="StyleIndex" />
    </xsd:attribute>
    <xsd:attribute name="Implicit" type="xsd:boolean" use="required" />
  </xsd:complexType>
  <xsd:complexType name="ArithmeticType">
    <xsd:sequence>
			<xsd:element name="ScalarOperator" type="shp:ScalarType" minOccurs="1" maxOccurs="2" />
    </xsd:sequence>
		<xsd:attribute name="Operation" type="shp:ArithmeticOperationType" use="required" />
  </xsd:complexType>
  <xsd:complexType name="LogicalType">
    <xsd:sequence>
			<xsd:element name="ScalarOperator" type="shp:ScalarType" minOccurs="1" maxOccurs="unbounded" />
    </xsd:sequence>
		<xsd:attribute name="Operation" type="shp:LogicalOperationType" use="required" />
  </xsd:complexType>
  <xsd:complexType name="UDAggregateType">
    <xsd:sequence>
      <xsd:element name="UDAggObject" type="shp:ObjectType" minOccurs="0" maxOccurs="1">
        <ssp:annotation bindToNodeAs="ud_aggregate" />
      </xsd:element>
      <xsd:element name="ScalarOperator" type="shp:ScalarType" minOccurs="0" maxOccurs="unbounded" />
    </xsd:sequence>
		<xsd:attribute name="Distinct" type="xsd:boolean" use="required" />
  </xsd:complexType>
  <xsd:complexType name="AggregateType">
    <xsd:sequence>
			<xsd:element name="ScalarOperator" type="shp:ScalarType" minOccurs="0" maxOccurs="unbounded" />
      <!-- Can take more than one child for Statman aggregate. May have 0 children for count(*) case-->
    </xsd:sequence>
		<xsd:attribute name="AggType" type="xsd:string" use="required" />
		<xsd:attribute name="Distinct" type="xsd:boolean" use="required" />
  </xsd:complexType>
  <xsd:complexType name="AssignType">
    <xsd:sequence>
      <xsd:choice>
				<xsd:element name="ColumnReference" type="shp:ColumnReferenceType" />
				<xsd:element name="ScalarOperator" type="shp:ScalarType" />
      </xsd:choice>
      <!--SSP: to satisfy parser :((( <xsd:element ssp:property="Operator" ssp:propertyType="Supratimas.Model.PlanScalar" name="ScalarOperator" type="shp:ScalarType"/>-->
			<!-- 			 Extended for PDW DMLOpType       -->
			<xsd:element name="SourceColumn" type="shp:ColumnReferenceType" minOccurs="0" maxOccurs="unbounded" />
			<xsd:element name="TargetColumn" type="shp:ColumnReferenceType" minOccurs="0" maxOccurs="unbounded" />
			<!-- 			 /Extended for PDW DMLOpType       -->
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="MultAssignType">
    <xsd:sequence>
			<xsd:element name="Assign" type="shp:AssignType" minOccurs="0" maxOccurs="unbounded" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="ConditionalType">
    <xsd:sequence>
			<xsd:element name="Condition" type="shp:ScalarExpressionType" />
			<xsd:element name="Then" type="shp:ScalarExpressionType" />
			<xsd:element name="Else" type="shp:ScalarExpressionType" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="IntrinsicType">
    <xsd:sequence>
			<xsd:element name="ScalarOperator" type="shp:ScalarType" minOccurs="0" maxOccurs="unbounded" />
    </xsd:sequence>
		<xsd:attribute name="FunctionName" type="xsd:string" use="required" />
  </xsd:complexType>
  <xsd:complexType name="ScalarSequenceType">
		<xsd:attribute name="FunctionName" type="xsd:string" use="required" />
  </xsd:complexType>
  <xsd:complexType name="UDFType">
    <xsd:sequence>
			<xsd:element name="ScalarOperator" type="shp:ScalarType" minOccurs="0" maxOccurs="unbounded" />
			<xsd:element name="CLRFunction" type="shp:CLRFunctionType" minOccurs="0" maxOccurs="1" />
    </xsd:sequence>
		<xsd:attribute name="FunctionName" type="xsd:string" use="required" />
		<xsd:attribute name="IsClrFunction" type="xsd:boolean" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="UDTMethodType">
    <xsd:sequence>
			<xsd:element name="CLRFunction" type="shp:CLRFunctionType" minOccurs="0" maxOccurs="1" />
			<xsd:element name="ScalarOperator" type="shp:ScalarType" minOccurs="0" maxOccurs="unbounded" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="CLRFunctionType">
		<xsd:sequence>
		</xsd:sequence>
		<xsd:attribute name="Assembly" type="xsd:string" use="optional" />
		<xsd:attribute name="Class" type="xsd:string" use="required" />
		<xsd:attribute name="Method" type="xsd:string" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="SubqueryType">
    <xsd:sequence>
			<xsd:element name="ScalarOperator" type="shp:ScalarType" minOccurs="0" maxOccurs="1" />
			<xsd:element name="RelOp" type="shp:RelOpType" />
    </xsd:sequence>
		<xsd:attribute name="Operation" type="shp:SubqueryOperationType" use="required" />
  </xsd:complexType>
  <xsd:simpleType name="SubqueryOperationType">
    <xsd:restriction base="xsd:string">
			<xsd:enumeration value="EQ ALL" />
			<xsd:enumeration value="EQ ANY" />
			<xsd:enumeration value="EXISTS" />
			<xsd:enumeration value="GE ALL" />
			<xsd:enumeration value="GE ANY" />
			<xsd:enumeration value="GT ALL" />
			<xsd:enumeration value="GT ANY" />
			<xsd:enumeration value="IN" />
			<xsd:enumeration value="LE ALL" />
			<xsd:enumeration value="LE ANY" />
			<xsd:enumeration value="LT ALL" />
			<xsd:enumeration value="LT ANY" />
			<xsd:enumeration value="NE ALL" />
			<xsd:enumeration value="NE ANY" />
    </xsd:restriction>
  </xsd:simpleType>
	<!-- 
   ***********************************************************
   **
   **  Parameter sensitive plan optimization schema definition
   **
   **
   **
   ***********************************************************
   -->
	<xsd:complexType name="DispatcherType">
		<xsd:annotation>
			<xsd:documentation>
				This is the dispatcher expression in XML format for the parameter sensitive plan.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:element name="ParameterSensitivePredicate" type="shp:ParameterSensitivePredicateType" minOccurs="1" maxOccurs="3" />
		</xsd:sequence>
	</xsd:complexType>
	<xsd:complexType name="ParameterSensitivePredicateType">
		<xsd:annotation>
			<xsd:documentation>
				This contains information related to the parameter sensitive predicate:
				Boundaries used to determine different ranges;
				Statistics information used to compute the boundaries;
				Predicate details.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:element name="StatisticsInfo" type="shp:StatsInfoType" minOccurs="1" maxOccurs="unbounded" />
			<xsd:element name="Predicate" type="shp:ScalarExpressionType" minOccurs="1" maxOccurs="1" />
		</xsd:sequence>
		<xsd:attribute name="LowBoundary" type="xsd:double" use="required" />
		<xsd:attribute name="HighBoundary" type="xsd:double" use="required" />
	</xsd:complexType>
  <!-- 
   *****************************************
   **  
   **  Enumerated Types
   **
   **
   **
   *****************************************
   -->
  <xsd:simpleType name="OrderType">
    <xsd:restriction base="xsd:string">
			<xsd:enumeration value="BACKWARD" />
			<xsd:enumeration value="FORWARD" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="SetPredicateType">
    <xsd:restriction base="xsd:string">
			<xsd:enumeration value="Update" />
			<xsd:enumeration value="Insert" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PartitionType">
    <xsd:restriction base="xsd:string">
			<xsd:enumeration value="Broadcast" />
			<xsd:enumeration value="Demand" />
			<xsd:enumeration value="Hash" />
			<xsd:enumeration value="NoPartitioning" />
			<xsd:enumeration value="Range" />
			<xsd:enumeration value="RoundRobin" />
			<xsd:enumeration value="CloneLocation" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CompareOpType">
    <xsd:restriction base="xsd:string">
			<xsd:enumeration value="BINARY IS" />
			<xsd:enumeration value="BOTH NULL" />
			<xsd:enumeration value="EQ" />
			<xsd:enumeration value="GE" />
			<xsd:enumeration value="GT" />
			<xsd:enumeration value="IS" />
			<xsd:enumeration value="IS NOT" />
			<xsd:enumeration value="IS NOT NULL" />
			<xsd:enumeration value="IS NULL" />
			<xsd:enumeration value="LE" />
			<xsd:enumeration value="LT" />
			<xsd:enumeration value="NE" />
			<xsd:enumeration value="ONE NULL" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ArithmeticOperationType">
    <xsd:restriction base="xsd:string">
			<xsd:enumeration value="ADD" />
			<xsd:enumeration value="BIT_ADD" />
			<xsd:enumeration value="BIT_AND" />
			<xsd:enumeration value="BIT_COMBINE" />
			<xsd:enumeration value="BIT_NOT" />
			<xsd:enumeration value="BIT_OR" />
			<xsd:enumeration value="BIT_XOR" />
			<xsd:enumeration value="DIV" />
      <xsd:enumeration value="HASH">
        <ssp:annotation preserveCase="true" />
      </xsd:enumeration>
			<xsd:enumeration value="MINUS" />
			<xsd:enumeration value="MOD" />
			<xsd:enumeration value="MULT" />
			<xsd:enumeration value="SUB" />
			<xsd:enumeration value="CONCAT" />
    </xsd:restriction>
    <ssp:annotation keepAsIs="true" />
  </xsd:simpleType>
  <xsd:simpleType name="LogicalOperationType">
    <xsd:restriction base="xsd:string">
			<xsd:enumeration value="AND" />
			<xsd:enumeration value="IMPLIES" />
			<xsd:enumeration value="IS NOT NULL" />
			<xsd:enumeration value="IS NULL" />
			<xsd:enumeration value="IS" />
			<xsd:enumeration value="IsFalseOrNull" />
			<xsd:enumeration value="NOT" />
			<xsd:enumeration value="OR" />
			<xsd:enumeration value="XOR" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="LogicalOpType">
    <xsd:annotation>
			<xsd:documentation>
			 These are the logical operators to which "query"
                         portions of T-SQL statement are translated. Subsequent
                         to that translation, a physical operator is chosen for
                         evaluating each logical operator. The SQL Server query
                         optimizer uses a cost-based approach to decide which 
                         physical operator will implement a logical operator.
 			</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="Aggregate" />
			<xsd:enumeration value="Anti Diff" />
			<xsd:enumeration value="Assert" />
			<xsd:enumeration value="Async Concat" />
			<xsd:enumeration value="Batch Hash Table Build" />
			<xsd:enumeration value="Bitmap Create" />
			<xsd:enumeration value="Clustered Index Scan" />
			<xsd:enumeration value="Clustered Index Seek" />
			<xsd:enumeration value="Clustered Update" />
			<xsd:enumeration value="Collapse" />
			<xsd:enumeration value="Compute Scalar" />
			<xsd:enumeration value="Concatenation" />
			<xsd:enumeration value="Constant Scan" />
			<!-- 			 PDW       -->
			<xsd:enumeration value="Constant Table Get" />
			<!-- 			 /PDW       -->
			<xsd:enumeration value="Cross Join" />
			<!-- 			 PDW       -->
			<xsd:enumeration value="Delete" />
			<!-- 			 /PDW       -->
			<xsd:enumeration value="Deleted Scan" />
			<xsd:enumeration value="Distinct Sort" />
			<xsd:enumeration value="Distinct" />
			<xsd:enumeration value="Distribute Streams" />
			<xsd:enumeration value="Eager Spool" />
			<xsd:enumeration value="External Extraction Scan" />
			<!-- 			 PDW       -->
			<xsd:enumeration value="External Select" />
			<!-- 			 /PDW       -->
			<xsd:enumeration value="Filter" />
			<xsd:enumeration value="Flow Distinct" />
			<xsd:enumeration value="Foreign Key References Check" />
			<xsd:enumeration value="Full Outer Join" />
			<xsd:enumeration value="Gather Streams" />
			<!-- 			 PDW       -->
			<xsd:enumeration value="GbAgg" />
			<xsd:enumeration value="GbApply" />
			<xsd:enumeration value="Get" />
			<!-- 			 /PDW       -->
			<xsd:enumeration value="Generic" />
			<!-- 			 PDW       -->
			<xsd:enumeration value="Inner Apply" />
			<!-- 			 /PDW       -->
			<xsd:enumeration value="Index Scan" />
			<xsd:enumeration value="Index Seek" />
			<xsd:enumeration value="Inner Join" />
			<!-- 			 PDW       -->
			<xsd:enumeration value="Insert" />
			<!-- 			 /PDW       -->
			<xsd:enumeration value="Inserted Scan" />
			<xsd:enumeration value="Intersect" />
			<xsd:enumeration value="Intersect All" />
			<xsd:enumeration value="Lazy Spool" />
			<!-- 			 PDW       -->
			<xsd:enumeration value="Left Anti Semi Apply" />
			<xsd:enumeration value="Left Semi Apply" />
			<xsd:enumeration value="Left Outer Apply" />
			<!-- 			 /PDW       -->
			<xsd:enumeration value="Left Anti Semi Join" />
			<xsd:enumeration value="Left Diff" />
			<xsd:enumeration value="Left Diff All" />
			<xsd:enumeration value="Left Outer Join" />
			<xsd:enumeration value="Left Semi Join" />
			<!-- 			 PDW       -->
			<xsd:enumeration value="LocalCube" />
			<!-- 			 /PDW       -->
			<xsd:enumeration value="Log Row Scan" />
			<xsd:enumeration value="Merge" />
			<xsd:enumeration value="Merge Interval" />
			<xsd:enumeration value="Merge Stats" />
			<!-- 			 PDW       -->
			<xsd:enumeration value="Move" />
			<!-- 			 /PDW       -->
			<xsd:enumeration value="Parameter Table Scan" />
			<xsd:enumeration value="Partial Aggregate" />
			<xsd:enumeration value="Print" />
			<!-- 			 PDW       -->
			<xsd:enumeration value="Project" />
			<!-- 			 /PDW       -->
			<xsd:enumeration value="Put" />
			<xsd:enumeration value="Rank" />
			<xsd:enumeration value="Remote Delete" />
			<xsd:enumeration value="Remote Index Scan" />
			<xsd:enumeration value="Remote Index Seek" />
			<xsd:enumeration value="Remote Insert" />
			<xsd:enumeration value="Remote Query" />
			<xsd:enumeration value="Remote Scan" />
			<xsd:enumeration value="Remote Update" />
			<xsd:enumeration value="Repartition Streams" />
			<xsd:enumeration value="RID Lookup" />
			<xsd:enumeration value="Right Anti Semi Join" />
			<xsd:enumeration value="Right Diff" />
			<xsd:enumeration value="Right Diff All" />
			<xsd:enumeration value="Right Outer Join" />
			<xsd:enumeration value="Right Semi Join" />
			<xsd:enumeration value="Segment" />
			<xsd:enumeration value="Sequence" />
			<xsd:enumeration value="Sort" />
			<xsd:enumeration value="Split" />
			<xsd:enumeration value="Switch" />
			<xsd:enumeration value="Table-valued function" />
			<xsd:enumeration value="Table Scan" />
			<xsd:enumeration value="Top" />
			<xsd:enumeration value="TopN Sort" />
			<xsd:enumeration value="UDX" />
			<xsd:enumeration value="Union" />
			<!-- 			 PDW       -->
			<xsd:enumeration value="Union All" />
			<!-- 			 /PDW       -->
			<xsd:enumeration value="Update" />
			<xsd:enumeration value="Local Stats" />
			<xsd:enumeration value="Window Spool" />
			<xsd:enumeration value="Window Aggregate" />
			<xsd:enumeration value="Key Lookup" />
			<xsd:enumeration value="Extensible Column Store Scan" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PhysicalOpType">
    <xsd:annotation>
			<xsd:documentation>
    
                         Each of the physical operator is an iterator. An iterator
                         can answer three method calls: Init(), GetNext(), and Close().
                         Upon receiving an Init() call, an iterator initializes itself,
                         setting up any data structures if necessary. Upon receiving a
                         GetNext() call, the iterator produces the "next" packet of 
                         data and gives it to the iterator that made the GetNext() call.
                         To produce the "next" packet of data, the iterator may have to
                         make zero or more GetNext() (or even Init()) calls to its 
                         children. Upon receiving a Close() call, an iterator performs
                         some clean-up operations and shuts itself down. Typically, an
                         iterator receives one Init() call, followed by many GetNext()
                         calls, and then a single Close() call.

                         The "query" portion of a T-SQL statement is typically a tree
                         made up of iterators.  

                         Usually, there is a one-to-many mapping among logical operators
                         and physical operators. That is, usually multiple physical operators
                         can implement a logical operator. In some cases in SQL Server,
                         however, a physical operator can implement multiple logical operators.
			</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="Adaptive Join" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="Apply" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="Assert" />
      <xsd:enumeration value="Batch Hash Table Build" />      
      <xsd:enumeration value="Bitmap" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="Broadcast" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="Clustered Index Delete" />
      <xsd:enumeration value="Clustered Index Insert" />
      <xsd:enumeration value="Clustered Index Scan" />
      <xsd:enumeration value="Clustered Index Seek" />
      <xsd:enumeration value="Clustered Index Update" />
      <xsd:enumeration value="Clustered Index Merge" />
      <xsd:enumeration value="Clustered Update" />
      <xsd:enumeration value="Collapse" />
      <xsd:enumeration value="Columnstore Index Delete" />
      <xsd:enumeration value="Columnstore Index Insert" />
      <xsd:enumeration value="Columnstore Index Merge" />
      <xsd:enumeration value="Columnstore Index Scan" />
      <xsd:enumeration value="Columnstore Index Update" />
      <xsd:enumeration value="Compute Scalar" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="Compute To Control Node" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="Concatenation" />
      <xsd:enumeration value="Constant Scan" />
      <xsd:enumeration value="Constant Table Get" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="Control To Compute Nodes" />
      <xsd:enumeration value="Delete" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="Deleted Scan" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="External Broadcast" />
      <xsd:enumeration value="External Extraction Scan" />
      <xsd:enumeration value="External Local Streaming" />
      <xsd:enumeration value="External Round Robin" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="External Select" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="External Shuffle" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="Filter" />
      <xsd:enumeration value="Foreign Key References Check" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="GbAgg" />
      <xsd:enumeration value="GbApply" />
      <xsd:enumeration value="Get" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="Generic" />
      <xsd:enumeration value="Hash Match" />
      <xsd:enumeration value="Index Delete" />
      <xsd:enumeration value="Index Insert" />
      <xsd:enumeration value="Index Scan" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="Insert" />
      <xsd:enumeration value="Join" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="Index Seek" />
      <xsd:enumeration value="Index Spool" />
      <xsd:enumeration value="Index Update" />
      <xsd:enumeration value="Inserted Scan" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="LocalCube" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="Log Row Scan" />
      <xsd:enumeration value="Merge Interval" />
      <xsd:enumeration value="Merge Join" />
      <xsd:enumeration value="Nested Loops" />
      <xsd:enumeration value="Online Index Insert" />
      <xsd:enumeration value="Parallelism" />
      <xsd:enumeration value="Parameter Table Scan" />
      <xsd:enumeration value="Print" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="Project" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="Put" />
      <xsd:enumeration value="Rank" />
      <xsd:enumeration value="Remote Delete" />
      <xsd:enumeration value="Remote Index Scan" />
      <xsd:enumeration value="Remote Index Seek" />
      <xsd:enumeration value="Remote Insert" />
      <xsd:enumeration value="Remote Query" />
      <xsd:enumeration value="Remote Scan" />
      <xsd:enumeration value="Remote Update" />
      <xsd:enumeration value="RID Lookup" />
      <xsd:enumeration value="Row Count Spool" />
      <xsd:enumeration value="Segment" />
      <xsd:enumeration value="Sequence" />
      <xsd:enumeration value="Sequence Project" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="Shuffle" />
      <xsd:enumeration value="Single Source Round Robin Move" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="Sort" />
      <xsd:enumeration value="Split" />
      <xsd:enumeration value="Stream Aggregate" />
      <xsd:enumeration value="Switch" />
      <xsd:enumeration value="Table Delete" />
      <xsd:enumeration value="Table Insert" />
      <xsd:enumeration value="Table Merge" />
      <xsd:enumeration value="Table Scan" />
      <xsd:enumeration value="Table Spool" />
      <xsd:enumeration value="Table Update" />
      <xsd:enumeration value="Table-valued function" />
      <xsd:enumeration value="Top" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="Trim" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="UDX" />
      <!-- 			 PDW       -->
      <xsd:enumeration value="Union" />
      <xsd:enumeration value="Union All" />
      <!-- 			 /PDW       -->
      <xsd:enumeration value="Window Aggregate" />
      <xsd:enumeration value="Window Spool" />
      <xsd:enumeration value="Key Lookup" />
      <xsd:enumeration value="Extensible Column Store Scan" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="SetOptionsType">
    <xsd:annotation>
      <xsd:documentation>The set options that affects query cost</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="ANSI_NULLS" type="shp:ONOFF">
      <ssp:annotation statementSetter="ansi.push('ANSI NULLS ' + {{value}})" />
    </xsd:attribute>
    <xsd:attribute name="ANSI_PADDING" type="shp:ONOFF">
      <ssp:annotation statementSetter="ansi.push('ANSI PADDING ' + {{value}})"/>
    </xsd:attribute>
    <xsd:attribute name="ANSI_WARNINGS" type="shp:ONOFF">
      <ssp:annotation statementSetter="ansi.push('ANSI WARNINGS ' + {{value}})"/>
    </xsd:attribute>
    <xsd:attribute name="ARITHABORT" type="shp:ONOFF">
      <ssp:annotation statementSetter="ansi.push('ANSI ARITHABORT ' + {{value}})"/>
    </xsd:attribute>
    <xsd:attribute name="CONCAT_NULL_YIELDS_NULL" type="shp:ONOFF">
      <ssp:annotation statementSetter="ansi.push('CONCAT NULL YIELDS NULL ' + {{value}})" />
    </xsd:attribute>
    <xsd:attribute name="NUMERIC_ROUNDABORT" type="shp:ONOFF">
      <ssp:annotation statementSetter="ansi.push('NUMERIC ROUNDABORT ' + {{value}})"/>
    </xsd:attribute>
    <xsd:attribute name="QUOTED_IDENTIFIER" type="shp:ONOFF">
      <ssp:annotation statementSetter="ansi.push('QUOTED IDENTIFIER ' + {{value}})"/>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:simpleType name="IndexKindType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="Heap" /> 
      <xsd:enumeration value="Clustered" />
      <xsd:enumeration value="FTSChangeTracking" />
      <xsd:enumeration value="FTSMapping" />
      <xsd:enumeration value="NonClustered" />
      <xsd:enumeration value="PrimaryXML" /> 
      <xsd:enumeration value="SecondaryXML" /> 
      <xsd:enumeration value="Spatial" /> 
      <xsd:enumeration value="ViewClustered" />
      <xsd:enumeration value="ViewNonClustered" />
      <xsd:enumeration value="NonClusteredHash" /> 
      <xsd:enumeration value="SelectiveXML" />
      <xsd:enumeration value="SecondarySelectiveXML" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CloneAccessScopeType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="Primary" /> 
      <xsd:enumeration value="Secondary" />
      <xsd:enumeration value="Both" /> 
      <xsd:enumeration value="Either" /> 
      <xsd:enumeration value="ExactMatch" />
      <xsd:enumeration value="Local" />
    </xsd:restriction>
  </xsd:simpleType>
</xsd:schema>
